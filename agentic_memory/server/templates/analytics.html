{% extends "base.html" %}
{% block content %}
<div class="analytics-container">
    <!-- Overview Stats -->
    <div class="panel">
        <h3>System Overview</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="total-memories">-</div>
                <div class="stat-label">Total Memories</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="unique-sessions">-</div>
                <div class="stat-label">Unique Sessions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="unique-actors">-</div>
                <div class="stat-label">Unique Actors</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avg-tokens">-</div>
                <div class="stat-label">Avg Tokens/Memory</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="date-range">-</div>
                <div class="stat-label">Date Range</div>
            </div>
        </div>
    </div>
    
    <!-- Entity Analytics -->
    <div class="panel">
        <h3>Entity Analysis</h3>
        <div class="entity-controls">
            <button onclick="loadEntityAnalytics(500)" class="btn-secondary">Top 500</button>
            <button onclick="loadEntityAnalytics(1000)" class="btn-secondary">Top 1000</button>
            <button onclick="loadEntityAnalytics(5000)" class="btn-secondary">Top 5000</button>
        </div>
        
        <div class="analytics-grid">
            <div class="analytics-section">
                <h4>Top What Items</h4>
                <div id="top-entities" class="entity-list"></div>
            </div>
            
            <div class="analytics-section">
                <h4>5W1H Network Visualization</h4>
                <div class="network-controls">
                    <button onclick="setNetworkOverlay('what')" class="network-btn active" data-type="what">What</button>
                    <button onclick="setNetworkOverlay('who')" class="network-btn" data-type="who">Who</button>
                    <button onclick="setNetworkOverlay('when')" class="network-btn" data-type="when">When</button>
                    <button onclick="setNetworkOverlay('where')" class="network-btn" data-type="where">Where</button>
                    <button onclick="setNetworkOverlay('why')" class="network-btn" data-type="why">Why</button>
                    <button onclick="setNetworkOverlay('how')" class="network-btn" data-type="how">How</button>
                </div>
                <div class="network-container">
                    <canvas id="entity-network" width="600" height="500"></canvas>
                    <div class="network-tooltip" id="network-tooltip" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Temporal Analytics -->
    <div class="panel">
        <h3>Temporal Distribution</h3>
        <div class="temporal-controls">
            <button onclick="loadTemporalAnalytics(7)" class="btn-secondary">7 Days</button>
            <button onclick="loadTemporalAnalytics(30)" class="btn-secondary">30 Days</button>
            <button onclick="loadTemporalAnalytics(90)" class="btn-secondary">90 Days</button>
        </div>
        
        <canvas id="temporal-chart" width="1200" height="300"></canvas>
        
        <div id="temporal-stats" class="temporal-stats"></div>
    </div>
    
    <!-- Score Analysis -->
    <div class="panel">
        <h3>Query Score Analysis</h3>
        <div class="score-section">
            <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                <input type="text" id="score-query" placeholder="Enter query to analyze..." style="flex: 1;" />
                <button onclick="analyzeScores()" class="btn-primary">Analyze</button>
            </div>
            
            <div class="analytics-grid">
                <div class="analytics-section">
                    <h4>Score Distribution</h4>
                    <canvas id="score-distribution" width="400" height="300"></canvas>
                </div>
                
                <div class="analytics-section">
                    <h4>Component Averages</h4>
                    <div id="component-averages"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.analytics-container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 1rem;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
}

.stat-card {
    background: var(--synth-surface);
    padding: 1.5rem;
    border-radius: 8px;
    border: 1px solid var(--synth-border);
    text-align: center;
    position: relative;
    overflow: hidden;
}

.stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
}

.stat-value {
    font-size: 2rem;
    font-weight: bold;
    color: var(--synth-cyan);
    text-shadow: 0 0 10px var(--synth-cyan);
}

.stat-label {
    color: var(--synth-text-muted);
    text-transform: uppercase;
    font-size: 0.75rem;
    margin-top: 0.5rem;
}

.entity-controls,
.temporal-controls {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.analytics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

.analytics-section {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid var(--synth-border);
}

.analytics-section h4 {
    color: var(--synth-pink);
    margin-top: 0;
    margin-bottom: 1rem;
}

.entity-list {
    max-height: 400px;
    overflow-y: auto;
}

.entity-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    border-bottom: 1px solid var(--synth-border);
    cursor: pointer;
    transition: background 0.3s;
}

.entity-item:hover {
    background: rgba(0, 255, 255, 0.1);
}

.entity-name {
    color: var(--synth-text);
    flex: 1;
}

.entity-count {
    color: var(--synth-cyan);
    font-weight: bold;
    margin-left: 1rem;
}

.entity-bar {
    height: 4px;
    background: linear-gradient(90deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
    margin-top: 0.25rem;
    border-radius: 2px;
}

.network-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background: var(--synth-surface);
    border-radius: 8px;
    border: 1px solid var(--synth-border);
}

.network-btn {
    padding: 0.4rem 0.8rem;
    background: transparent;
    color: var(--synth-text-muted);
    border: 1px solid transparent;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.network-btn:hover {
    color: var(--synth-cyan);
    border-color: var(--synth-cyan);
    text-shadow: 0 0 10px var(--synth-cyan);
}

.network-btn.active {
    background: linear-gradient(135deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
    color: var(--synth-dark-bg);
    font-weight: bold;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

.network-container {
    position: relative;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid var(--synth-border);
}

.network-container canvas {
    display: block;
    margin: 0 auto;
    cursor: grab;
}

.network-container canvas:active {
    cursor: grabbing;
}

.network-tooltip {
    position: absolute;
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-cyan);
    border-radius: 4px;
    padding: 0.5rem;
    font-size: 0.8rem;
    pointer-events: none;
    z-index: 1000;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    max-width: 250px;
}

.temporal-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin-top: 1.5rem;
}

.temporal-stat {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 4px;
    border: 1px solid var(--synth-border);
}

.component-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: var(--synth-surface);
    border-radius: 4px;
}

.component-name {
    color: var(--synth-cyan);
    font-weight: 600;
}

.component-value {
    color: var(--synth-text);
    font-family: monospace;
}

.component-visual {
    height: 4px;
    background: var(--synth-cyan);
    border-radius: 2px;
    margin-top: 0.25rem;
}

canvas {
    max-width: 100%;
    height: auto;
}
</style>

<script>
// Load initial stats
document.addEventListener('DOMContentLoaded', function() {
    loadStats();
    loadEntityAnalytics(1000);
    loadTemporalAnalytics(30);
});

// Load system stats
async function loadStats() {
    try {
        const response = await fetch('/api/stats');
        if (response.ok) {
            const stats = await response.json();
            
            document.getElementById('total-memories').textContent = 
                stats.total_memories ? stats.total_memories.toLocaleString() : '0';
            document.getElementById('unique-sessions').textContent = 
                stats.unique_sessions ? stats.unique_sessions.toLocaleString() : '0';
            document.getElementById('unique-actors').textContent = 
                stats.unique_actors ? stats.unique_actors.toLocaleString() : '0';
            document.getElementById('avg-tokens').textContent = 
                stats.avg_tokens ? Math.round(stats.avg_tokens).toLocaleString() : '0';
            
            if (stats.date_range && stats.date_range.from && stats.date_range.to) {
                const from = new Date(stats.date_range.from).toLocaleDateString();
                const to = new Date(stats.date_range.to).toLocaleDateString();
                document.getElementById('date-range').textContent = `${from} - ${to}`;
            } else {
                document.getElementById('date-range').textContent = 'N/A';
            }
        }
    } catch (error) {
        console.error('Failed to load stats:', error);
    }
}

// Load entity analytics
async function loadEntityAnalytics(limit) {
    try {
        const response = await fetch(`/api/analytics/entities?limit=${limit}`);
        if (response.ok) {
            const data = await response.json();
            
            // Display top entities
            displayTopEntities(data.top_entities);
            
            // Store and draw entity network
            networkData.what = data.co_occurrence;
            drawEntityNetwork(data.co_occurrence, 'what');
        }
    } catch (error) {
        console.error('Failed to load entity analytics:', error);
    }
}

// Display top entities
function displayTopEntities(entities) {
    const container = document.getElementById('top-entities');
    
    if (!entities || entities.length === 0) {
        container.innerHTML = '<p style="color: var(--synth-text-muted);">No entities found</p>';
        return;
    }
    
    const maxCount = entities[0][1];
    
    container.innerHTML = '';
    entities.slice(0, 30).forEach(([entity, count]) => {
        const item = document.createElement('div');
        item.className = 'entity-item';
        item.onclick = () => searchForEntity(entity);
        
        const barWidth = (count / maxCount) * 100;
        
        item.innerHTML = `
            <span class="entity-name">${entity}</span>
            <span class="entity-count">${count}</span>
            <div class="entity-bar" style="width: ${barWidth}%;"></div>
        `;
        
        container.appendChild(item);
    });
}

// Network state management
let currentNetworkType = 'what';
let networkData = {
    what: null,
    who: null,
    when: null,
    where: null,
    why: null,
    how: null
};
let networkNodes = {};
let networkLinks = [];
let isDragging = false;
let draggedNode = null;
let mousePos = { x: 0, y: 0 };
let animationFrame = null;

// Set network overlay type
function setNetworkOverlay(type) {
    currentNetworkType = type;
    
    // Update button states
    document.querySelectorAll('.network-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
    });
    
    // Load network data for the selected type
    loadNetworkData(type);
}

// Load network data for specific 5W1H component
async function loadNetworkData(type) {
    try {
        const response = await fetch(`/api/analytics/network/${type}`);
        if (response.ok) {
            const data = await response.json();
            networkData[type] = data.co_occurrence || [];
            drawEntityNetwork(networkData[type], type);
        }
    } catch (error) {
        console.error(`Failed to load ${type} network:`, error);
        // Fall back to existing data if available
        if (type === 'what' && networkData.what) {
            drawEntityNetwork(networkData.what, type);
        }
    }
}

// Enhanced entity network drawing with physics and interactivity
function drawEntityNetwork(coOccurrence, networkType = 'what') {
    const canvas = document.getElementById('entity-network');
    const ctx = canvas.getContext('2d');
    
    // Clear any existing animation
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    
    // Clear canvas and draw background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw synthwave grid background
    drawGridBackground(ctx, canvas.width, canvas.height);
    
    if (!coOccurrence || coOccurrence.length === 0) {
        ctx.fillStyle = 'var(--synth-text-muted)';
        ctx.font = '14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`No ${networkType} co-occurrence data`, canvas.width/2, canvas.height/2);
        return;
    }
    
    // Initialize nodes with physics properties
    networkNodes = {};
    networkLinks = [];
    
    coOccurrence.forEach(link => {
        if (!networkNodes[link.source]) {
            networkNodes[link.source] = {
                id: link.source,
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                vx: 0,
                vy: 0,
                connections: 0,
                weight: 0
            };
        }
        if (!networkNodes[link.target]) {
            networkNodes[link.target] = {
                id: link.target,
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                vx: 0,
                vy: 0,
                connections: 0,
                weight: 0
            };
        }
        
        networkNodes[link.source].connections++;
        networkNodes[link.target].connections++;
        networkNodes[link.source].weight += link.weight;
        networkNodes[link.target].weight += link.weight;
        
        networkLinks.push({
            source: networkNodes[link.source],
            target: networkNodes[link.target],
            weight: link.weight
        });
    });
    
    // Set up mouse event handlers
    setupNetworkInteraction(canvas);
    
    // Start physics simulation
    animateNetwork(ctx, canvas, networkType);
}

// Draw synthwave grid background
function drawGridBackground(ctx, width, height) {
    // Create gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, 'rgba(25, 20, 40, 0.95)');
    gradient.addColorStop(1, 'rgba(15, 10, 30, 0.95)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }
    
    // Horizontal lines with perspective
    for (let y = 0; y <= height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
}

// Setup mouse interaction for network
function setupNetworkInteraction(canvas) {
    // Remove existing listeners
    const newCanvas = canvas.cloneNode(true);
    canvas.parentNode.replaceChild(newCanvas, canvas);
    const updatedCanvas = document.getElementById('entity-network');
    
    updatedCanvas.addEventListener('mousedown', (e) => {
        const rect = updatedCanvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        
        // Check if clicking on a node
        Object.values(networkNodes).forEach(node => {
            const dist = Math.sqrt(Math.pow(node.x - mousePos.x, 2) + Math.pow(node.y - mousePos.y, 2));
            const radius = Math.min(8 + node.weight, 20);
            if (dist <= radius) {
                isDragging = true;
                draggedNode = node;
                updatedCanvas.style.cursor = 'grabbing';
            }
        });
    });
    
    updatedCanvas.addEventListener('mousemove', (e) => {
        const rect = updatedCanvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        
        if (isDragging && draggedNode) {
            draggedNode.x = mousePos.x;
            draggedNode.y = mousePos.y;
            draggedNode.vx = 0;
            draggedNode.vy = 0;
        } else {
            // Check if hovering over a node
            let hovering = false;
            Object.values(networkNodes).forEach(node => {
                const dist = Math.sqrt(Math.pow(node.x - mousePos.x, 2) + Math.pow(node.y - mousePos.y, 2));
                const radius = Math.min(8 + node.weight, 20);
                if (dist <= radius) {
                    hovering = true;
                    showNetworkTooltip(node, e.clientX, e.clientY);
                }
            });
            
            if (!hovering) {
                hideNetworkTooltip();
            }
            
            updatedCanvas.style.cursor = hovering ? 'grab' : 'default';
        }
    });
    
    updatedCanvas.addEventListener('mouseup', () => {
        isDragging = false;
        draggedNode = null;
        updatedCanvas.style.cursor = 'default';
    });
    
    updatedCanvas.addEventListener('mouseleave', () => {
        isDragging = false;
        draggedNode = null;
        hideNetworkTooltip();
        updatedCanvas.style.cursor = 'default';
    });
}

// Show tooltip for network node
function showNetworkTooltip(node, x, y) {
    const tooltip = document.getElementById('network-tooltip');
    if (tooltip) {
        tooltip.innerHTML = `
            <strong>${node.id}</strong><br>
            Connections: ${node.connections}<br>
            Weight: ${node.weight.toFixed(1)}
        `;
        tooltip.style.left = `${x + 10}px`;
        tooltip.style.top = `${y - 30}px`;
        tooltip.style.display = 'block';
    }
}

// Hide network tooltip
function hideNetworkTooltip() {
    const tooltip = document.getElementById('network-tooltip');
    if (tooltip) {
        tooltip.style.display = 'none';
    }
}

// Animate network with physics
function animateNetwork(ctx, canvas, networkType) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const damping = 0.95;
    const repulsion = 5000;
    const attraction = 0.001;
    
    // Apply physics forces
    Object.values(networkNodes).forEach(node => {
        if (isDragging && node === draggedNode) return;
        
        // Reset forces
        let fx = 0, fy = 0;
        
        // Repulsion between nodes
        Object.values(networkNodes).forEach(other => {
            if (node === other) return;
            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0 && dist < 200) {
                const force = repulsion / (dist * dist);
                fx += (dx / dist) * force;
                fy += (dy / dist) * force;
            }
        });
        
        // Attraction along links
        networkLinks.forEach(link => {
            let other = null;
            if (link.source === node) other = link.target;
            if (link.target === node) other = link.source;
            
            if (other) {
                const dx = other.x - node.x;
                const dy = other.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const force = dist * attraction * link.weight;
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                }
            }
        });
        
        // Center gravity
        fx += (centerX - node.x) * 0.0001;
        fy += (centerY - node.y) * 0.0001;
        
        // Update velocity
        node.vx = (node.vx + fx) * damping;
        node.vy = (node.vy + fy) * damping;
        
        // Update position
        node.x += node.vx;
        node.y += node.vy;
        
        // Keep within bounds
        node.x = Math.max(20, Math.min(canvas.width - 20, node.x));
        node.y = Math.max(20, Math.min(canvas.height - 20, node.y));
    });
    
    // Clear and redraw
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGridBackground(ctx, canvas.width, canvas.height);
    
    // Get color scheme for network type
    const colors = getNetworkColors(networkType);
    
    // Draw links with glow effect
    networkLinks.forEach(link => {
        const gradient = ctx.createLinearGradient(
            link.source.x, link.source.y,
            link.target.x, link.target.y
        );
        gradient.addColorStop(0, colors.linkStart);
        gradient.addColorStop(1, colors.linkEnd);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = Math.min(link.weight / 2, 4);
        ctx.globalAlpha = 0.3 + Math.min(link.weight * 0.1, 0.5);
        
        // Draw glow
        ctx.shadowColor = colors.glow;
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    });
    
    // Draw nodes with synthwave style
    Object.values(networkNodes).forEach(node => {
        const radius = Math.min(8 + node.weight, 20);
        
        // Outer glow
        const glowGradient = ctx.createRadialGradient(
            node.x, node.y, 0,
            node.x, node.y, radius * 2
        );
        glowGradient.addColorStop(0, colors.nodeCenter);
        glowGradient.addColorStop(0.5, colors.nodeMid);
        glowGradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, radius * 2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Main node
        const nodeGradient = ctx.createRadialGradient(
            node.x - radius/3, node.y - radius/3, 0,
            node.x, node.y, radius
        );
        nodeGradient.addColorStop(0, colors.nodeHighlight);
        nodeGradient.addColorStop(1, colors.nodeBase);
        
        ctx.fillStyle = nodeGradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Node border
        ctx.strokeStyle = colors.nodeBorder;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Label with shadow
        ctx.fillStyle = colors.text;
        ctx.font = `${10 + Math.min(node.weight / 5, 4)}px "Courier New", monospace`;
        ctx.textAlign = 'center';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 3;
        ctx.fillText(node.id.substring(0, 20), node.x, node.y - radius - 8);
        ctx.shadowBlur = 0;
    });
    
    // Continue animation
    animationFrame = requestAnimationFrame(() => animateNetwork(ctx, canvas, networkType));
}

// Get color scheme for network type
function getNetworkColors(type) {
    const schemes = {
        what: {
            nodeBase: '#00ffff',
            nodeHighlight: '#80ffff',
            nodeCenter: 'rgba(0, 255, 255, 0.3)',
            nodeMid: 'rgba(0, 255, 255, 0.1)',
            nodeBorder: '#00cccc',
            linkStart: 'rgba(0, 255, 255, 0.6)',
            linkEnd: 'rgba(0, 200, 200, 0.3)',
            glow: '#00ffff',
            text: '#00ffff'
        },
        who: {
            nodeBase: '#ff00ff',
            nodeHighlight: '#ff80ff',
            nodeCenter: 'rgba(255, 0, 255, 0.3)',
            nodeMid: 'rgba(255, 0, 255, 0.1)',
            nodeBorder: '#cc00cc',
            linkStart: 'rgba(255, 0, 255, 0.6)',
            linkEnd: 'rgba(200, 0, 200, 0.3)',
            glow: '#ff00ff',
            text: '#ff00ff'
        },
        when: {
            nodeBase: '#ffff00',
            nodeHighlight: '#ffff80',
            nodeCenter: 'rgba(255, 255, 0, 0.3)',
            nodeMid: 'rgba(255, 255, 0, 0.1)',
            nodeBorder: '#cccc00',
            linkStart: 'rgba(255, 255, 0, 0.6)',
            linkEnd: 'rgba(200, 200, 0, 0.3)',
            glow: '#ffff00',
            text: '#ffff00'
        },
        where: {
            nodeBase: '#00ff00',
            nodeHighlight: '#80ff80',
            nodeCenter: 'rgba(0, 255, 0, 0.3)',
            nodeMid: 'rgba(0, 255, 0, 0.1)',
            nodeBorder: '#00cc00',
            linkStart: 'rgba(0, 255, 0, 0.6)',
            linkEnd: 'rgba(0, 200, 0, 0.3)',
            glow: '#00ff00',
            text: '#00ff00'
        },
        why: {
            nodeBase: '#ff8800',
            nodeHighlight: '#ffaa44',
            nodeCenter: 'rgba(255, 136, 0, 0.3)',
            nodeMid: 'rgba(255, 136, 0, 0.1)',
            nodeBorder: '#cc6600',
            linkStart: 'rgba(255, 136, 0, 0.6)',
            linkEnd: 'rgba(200, 100, 0, 0.3)',
            glow: '#ff8800',
            text: '#ff8800'
        },
        how: {
            nodeBase: '#8800ff',
            nodeHighlight: '#aa44ff',
            nodeCenter: 'rgba(136, 0, 255, 0.3)',
            nodeMid: 'rgba(136, 0, 255, 0.1)',
            nodeBorder: '#6600cc',
            linkStart: 'rgba(136, 0, 255, 0.6)',
            linkEnd: 'rgba(100, 0, 200, 0.3)',
            glow: '#8800ff',
            text: '#8800ff'
        }
    };
    
    return schemes[type] || schemes.what;
}

// Load temporal analytics
async function loadTemporalAnalytics(days) {
    try {
        const response = await fetch(`/api/analytics/temporal?days=${days}`);
        if (response.ok) {
            const data = await response.json();
            drawTemporalChart(data.timeline);
            displayTemporalStats(data.timeline);
        }
    } catch (error) {
        console.error('Failed to load temporal analytics:', error);
    }
}

// Draw temporal chart
function drawTemporalChart(timeline) {
    const canvas = document.getElementById('temporal-chart');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!timeline || timeline.length === 0) {
        ctx.fillStyle = 'var(--synth-text-muted)';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No temporal data', canvas.width/2, canvas.height/2);
        return;
    }
    
    const padding = 40;
    const chartWidth = canvas.width - 2 * padding;
    const chartHeight = canvas.height - 2 * padding;
    const barWidth = chartWidth / timeline.length;
    
    const maxCount = Math.max(...timeline.map(t => t.memories));
    
    // Draw axes
    ctx.strokeStyle = 'var(--synth-border)';
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    
    // Draw bars
    timeline.forEach((day, index) => {
        const barHeight = (day.memories / maxCount) * chartHeight;
        const x = padding + index * barWidth;
        const y = canvas.height - padding - barHeight;
        
        // Bar
        ctx.fillStyle = 'var(--synth-cyan)';
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Date label (every 7th day)
        if (index % 7 === 0) {
            ctx.fillStyle = 'var(--synth-text)';
            ctx.font = '10px sans-serif';
            ctx.save();
            ctx.translate(x + barWidth/2, canvas.height - padding + 15);
            ctx.rotate(-Math.PI/4);
            ctx.textAlign = 'right';
            ctx.fillText(day.date, 0, 0);
            ctx.restore();
        }
    });
    
    // Title
    ctx.fillStyle = 'var(--synth-text)';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Memories Over Time', canvas.width/2, 20);
}

// Display temporal stats
function displayTemporalStats(timeline) {
    const container = document.getElementById('temporal-stats');
    
    if (!timeline || timeline.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    const totalMemories = timeline.reduce((sum, day) => sum + day.memories, 0);
    const avgPerDay = totalMemories / timeline.length;
    const maxDay = timeline.reduce((max, day) => day.memories > max.memories ? day : max);
    const totalSessions = timeline.reduce((sum, day) => sum + day.sessions, 0);
    
    container.innerHTML = `
        <div class="temporal-stat">
            <div class="stat-label">Total Period</div>
            <div class="stat-value">${timeline.length} days</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Avg Memories/Day</div>
            <div class="stat-value">${Math.round(avgPerDay)}</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Peak Day</div>
            <div class="stat-value">${maxDay.date}<br>${maxDay.memories} memories</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Total Sessions</div>
            <div class="stat-value">${totalSessions}</div>
        </div>
    `;
}

// Analyze scores for a query
async function analyzeScores() {
    const query = document.getElementById('score-query').value.trim();
    if (!query) {
        alert('Please enter a query to analyze');
        return;
    }
    
    try {
        // Get current weights from analyzer
        const weightsResponse = await fetch('/api/weights');
        const weights = await weightsResponse.json();
        
        const response = await fetch('/api/analytics/scores', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                weights: weights
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            drawScoreDistribution(data.score_distribution);
            displayComponentAverages(data.component_averages);
        }
    } catch (error) {
        console.error('Failed to analyze scores:', error);
    }
}

// Draw score distribution
function drawScoreDistribution(distribution) {
    const canvas = document.getElementById('score-distribution');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const labels = Object.keys(distribution);
    const values = Object.values(distribution);
    const maxValue = Math.max(...values, 1);
    
    const barWidth = canvas.width / labels.length;
    const chartHeight = canvas.height - 40;
    
    // Draw bars
    labels.forEach((label, index) => {
        const barHeight = (values[index] / maxValue) * chartHeight;
        const x = index * barWidth;
        const y = canvas.height - barHeight - 20;
        
        // Bar
        ctx.fillStyle = 'var(--synth-cyan)';
        ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
        
        // Label
        ctx.fillStyle = 'var(--synth-text)';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + barWidth/2, canvas.height - 5);
        
        // Count
        if (values[index] > 0) {
            ctx.fillText(values[index].toString(), x + barWidth/2, y - 5);
        }
    });
    
    // Title
    ctx.fillStyle = 'var(--synth-text)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Score Distribution', canvas.width/2, 15);
}

// Display component averages
function displayComponentAverages(averages) {
    const container = document.getElementById('component-averages');
    
    container.innerHTML = '';
    Object.entries(averages).forEach(([component, avg]) => {
        const bar = document.createElement('div');
        bar.className = 'component-bar';
        
        const width = avg * 100;
        
        bar.innerHTML = `
            <span class="component-name">${component}</span>
            <span class="component-value">${avg.toFixed(3)}</span>
            <div class="component-visual" style="width: ${width}%;"></div>
        `;
        
        container.appendChild(bar);
    });
}

// Search for entity in analyzer
function searchForEntity(entity) {
    // Navigate to analyzer with entity as query
    window.location.href = `/?query=${encodeURIComponent(entity)}`;
}
</script>
{% endblock %}