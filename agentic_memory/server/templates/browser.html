{% extends "base.html" %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/tables.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/modal.css') }}">
{% endblock %}

{% block content %}
<div class="browser-container">
    <!-- Filters Section -->
    <div class="panel">
        <h3>Filters</h3>
        <div class="filter-grid">
            <div class="filter-group">
                <label>Text Search</label>
                <input type="text" id="filter-search" placeholder="Search in memories..." />
            </div>
            
            <div class="filter-group">
                <label>Session ID</label>
                <input type="text" id="filter-session" placeholder="e.g., analyzer" />
            </div>
            
            <div class="filter-group">
                <label>Who (Actor)</label>
                <input type="text" id="filter-who" placeholder="e.g., user, llm" />
            </div>
            
            <div class="filter-group">
                <label>Where (Location)</label>
                <input type="text" id="filter-where" placeholder="e.g., digital, local_ui" />
            </div>
            
            <div class="filter-group">
                <label>Entity</label>
                <input type="text" id="filter-entity" placeholder="Search for entity..." />
            </div>
            
            <div class="filter-group">
                <label>Date From</label>
                <input type="datetime-local" id="filter-date-from" />
            </div>
            
            <div class="filter-group">
                <label>Date To</label>
                <input type="datetime-local" id="filter-date-to" />
            </div>
            
            <div class="filter-group">
                <label>Sort By</label>
                <select id="sort-by">
                    <option value="when_ts">When (Time)</option>
                    <option value="created_at">Created At</option>
                    <option value="memory_id">Memory ID</option>
                    <option value="session_id">Session ID</option>
                    <option value="token_count">Token Count</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Order</label>
                <select id="sort-order">
                    <option value="desc">Descending</option>
                    <option value="asc">Ascending</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Per Page</label>
                <select id="per-page">
                    <option value="25">25</option>
                    <option value="50" selected>50</option>
                    <option value="100">100</option>
                    <option value="200">200</option>
                </select>
            </div>
        </div>
        
        <div class="filter-actions">
            <button onclick="applyFilters()" class="btn-primary">Apply Filters</button>
            <button onclick="clearFilters()" class="btn-secondary">Clear All</button>
            <button onclick="exportMemories()" class="btn-secondary">Export Results</button>
            <button onclick="showImportDialog()" class="btn-secondary">Import Memories</button>
        </div>
    </div>
    
    <!-- Results Section -->
    <div class="panel">
        <h3>Memory Database <span id="memory-count"></span></h3>
        
        <!-- Pagination Top -->
        <div id="pagination-top" class="pagination"></div>
        
        <!-- Results Table -->
        <div class="table-container">
            <div class="table-wrapper">
                <table class="data-table" id="memories-table">
                    <thead>
                        <tr>
                            <th class="col-checkbox"><input type="checkbox" id="select-all" onchange="toggleSelectAll()" /></th>
                            <th class="col-memory-id sortable" onclick="sortTable('memory_id')">Memory ID <span class="sort-indicator"></span></th>
                            <th class="sortable" onclick="sortTable('session_id')">Session <span class="sort-indicator"></span></th>
                            <th class="sortable" onclick="sortTable('who_id')">Who <span class="sort-indicator"></span></th>
                            <th class="col-entities sortable" onclick="sortTable('what')">What <span class="sort-indicator"></span></th>
                            <th class="col-when sortable" onclick="sortTable('when_ts')">When <span class="sort-indicator"></span></th>
                            <th class="sortable" onclick="sortTable('where_value')">Where <span class="sort-indicator"></span></th>
                            <th>Why</th>
                            <th>How</th>
                            <th class="col-score sortable" onclick="sortTable('token_count')">Tokens <span class="sort-indicator"></span></th>
                            <th class="col-text">Raw Text</th>
                            <th class="col-actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="memories-tbody">
                        <!-- Memories will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Pagination Bottom -->
        <div id="pagination-bottom" class="pagination"></div>
        
        <!-- Bulk Actions -->
        <div class="bulk-actions" id="bulk-actions" style="display: none;">
            <span id="selected-count">0 selected</span>
            <button onclick="deleteSelected()" class="btn-danger">Delete Selected</button>
            <button onclick="exportSelected()" class="btn-secondary">Export Selected</button>
        </div>
    </div>
</div>

<!-- Memory Detail Modal -->
<div id="memory-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Memory Details</h3>
            <span class="close" onclick="closeModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div id="memory-details"></div>
        </div>
    </div>
</div>

<!-- Import Modal -->
<div id="import-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Import Memories</h3>
            <span class="close" onclick="closeImportModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="import-section">
                <h5>Upload File</h5>
                <p style="color: var(--synth-text-muted); font-size: 0.9rem; margin-bottom: 1rem;">
                    Supported formats: JSON (exported memories), CSV, or plain text files
                </p>
                
                <div class="file-upload-area" id="file-upload-area">
                    <input type="file" id="import-file" accept=".json,.csv,.txt" style="display: none;" onchange="handleFileSelect(event)" />
                    <div class="upload-prompt" onclick="document.getElementById('import-file').click()">
                        <div style="font-size: 2rem; color: var(--synth-cyan);">üìÅ</div>
                        <p>Click to select file or drag and drop</p>
                        <p style="font-size: 0.85rem; color: var(--synth-text-muted);">JSON, CSV, or TXT</p>
                    </div>
                </div>
                
                <div id="file-info" style="display: none; margin-top: 1rem;">
                    <div style="background: var(--synth-surface); padding: 1rem; border-radius: 4px; border: 1px solid var(--synth-cyan);">
                        <strong>Selected File:</strong> <span id="file-name"></span><br>
                        <strong>Size:</strong> <span id="file-size"></span><br>
                        <strong>Type:</strong> <span id="file-type"></span>
                    </div>
                </div>
                
                <div class="import-options" style="margin-top: 1.5rem;">
                    <label style="color: var(--synth-cyan); font-size: 0.875rem; font-weight: 600;">Session ID (optional)</label>
                    <input type="text" id="import-session-id" placeholder="e.g., import_2025" style="width: 100%; margin-bottom: 1rem;" />
                    
                    <button onclick="startImport()" id="start-import-btn" class="btn-primary" style="width: 100%;">Start Import</button>
                </div>
            </div>
            
            <!-- Import Jobs List -->
            <div class="import-jobs" style="margin-top: 2rem; border-top: 1px solid var(--synth-border); padding-top: 1.5rem;">
                <h5>Import Jobs</h5>
                <div id="import-jobs-list">
                    <p style="color: var(--synth-text-muted);">No import jobs yet</p>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.browser-container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 1rem;
}

.filter-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.filter-group label {
    color: var(--synth-cyan);
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
}

.filter-group input,
.filter-group select {
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    color: var(--synth-text);
    padding: 0.5rem;
    border-radius: 4px;
}

.filter-actions {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
}

.table-container {
    overflow-x: auto;
    margin: 1rem 0;
}

.pagination {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    justify-content: center;
    margin: 1rem 0;
}

.pagination button {
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    color: var(--synth-text);
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
}

.pagination button:hover:not(:disabled) {
    background: var(--synth-cyan);
    color: var(--synth-dark-bg);
}

.pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.pagination .page-info {
    color: var(--synth-text);
    margin: 0 1rem;
}

.bulk-actions {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 4px;
    display: flex;
    gap: 1rem;
    align-items: center;
    margin-top: 1rem;
}

.btn-danger {
    background: linear-gradient(135deg, #ff0040 0%, #ff10f0 100%);
    color: white;
    border: none;
    padding: 0.5rem 1.5rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}

.btn-danger:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 0, 64, 0.4);
}

.memory-row {
    cursor: pointer;
}

.memory-row:hover {
    background: rgba(0, 255, 255, 0.05);
}

.memory-row.selected {
    background: rgba(0, 255, 255, 0.1);
}

.file-upload-area {
    border: 2px dashed var(--synth-cyan);
    border-radius: 8px;
    padding: 2rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.file-upload-area:hover {
    background: rgba(0, 255, 255, 0.05);
    border-color: var(--synth-pink);
}

.file-upload-area.dragover {
    background: rgba(0, 255, 255, 0.1);
    border-color: var(--synth-pink);
}

.import-job {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    border: 1px solid var(--synth-border);
}

.import-job.processing {
    border-color: var(--synth-cyan);
    animation: pulse 2s infinite;
}

.import-job.completed {
    border-color: var(--synth-green);
}

.import-job.failed {
    border-color: var(--synth-pink);
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.progress-bar {
    width: 100%;
    height: 24px;
    background: var(--synth-dark-bg);
    border-radius: 10px;
    overflow: visible;
    margin: 0.5rem 0;
    position: relative;
    border: 1px solid var(--synth-border);
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
    transition: width 0.5s ease;
    border-radius: 9px;
    min-width: 0;
}

.progress-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 0.8rem;
    font-weight: bold;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
    z-index: 1;
    pointer-events: none;
}
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    min-width: 300px;
    max-width: 500px;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    z-index: 10000;
    animation: slideIn 0.3s ease-out;
    font-family: 'Space Mono', monospace;
    border: 1px solid;
}

.notification.success {
    background: linear-gradient(135deg, rgba(0, 255, 0, 0.1), rgba(0, 255, 255, 0.1));
    border-color: #00ff00;
    color: #00ff00;
}

.notification.error {
    background: linear-gradient(135deg, rgba(255, 0, 64, 0.1), rgba(255, 16, 240, 0.1));
    border-color: var(--synth-pink);
    color: var(--synth-pink);
}

.notification.warning {
    background: linear-gradient(135deg, rgba(255, 165, 0, 0.1), rgba(255, 255, 0, 0.1));
    border-color: #ffa500;
    color: #ffa500;
}

.notification.info {
    background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(128, 0, 255, 0.1));
    border-color: var(--synth-cyan);
    color: var(--synth-cyan);
}

.notification-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
}

.notification-message {
    flex: 1;
    font-size: 0.95rem;
    line-height: 1.4;
}

.notification-close {
    cursor: pointer;
    font-size: 1.2rem;
    opacity: 0.8;
    transition: opacity 0.2s;
}

.notification-close:hover {
    opacity: 1;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* Sortable headers */
.sortable {
    cursor: pointer;
    user-select: none;
    position: relative;
}

.sortable:hover {
    background: rgba(0, 255, 255, 0.1);
}

.sort-indicator {
    margin-left: 5px;
    font-size: 0.8em;
    color: var(--synth-cyan);
}

.sort-indicator::after {
    content: '‚Üï';
    opacity: 0.3;
}

.sortable.sort-asc .sort-indicator::after {
    content: '‚Üë';
    opacity: 1;
}

.sortable.sort-desc .sort-indicator::after {
    content: '‚Üì';
    opacity: 1;
}
</style>

<script>
// Notification system
function showNotification(type, message, duration = 5000) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    notification.innerHTML = `
        <div class="notification-content">
            <div class="notification-message">${message}</div>
            <span class="notification-close" onclick="this.parentElement.parentElement.remove()">‚úï</span>
        </div>
    `;
    
    // Add to body
    document.body.appendChild(notification);
    
    // Auto-remove after duration
    if (duration > 0) {
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease-out';
            setTimeout(() => notification.remove(), 300);
        }, duration);
    }
    
    return notification;
}

let currentPage = 1;
let currentFilters = {};
let selectedMemories = new Set();
let currentSortField = 'when_ts';
let currentSortOrder = 'desc';

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadMemories();
    
    // Set up enter key handlers
    document.querySelectorAll('.filter-group input').forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyFilters();
            }
        });
    });
});

// Load memories with current filters
async function loadMemories(page = 1) {
    currentPage = page;
    
    // Build query parameters
    const params = new URLSearchParams({
        page: page,
        per_page: document.getElementById('per-page').value,
        sort_by: currentSortField,
        sort_order: currentSortOrder
    });
    
    // Add filters
    const search = document.getElementById('filter-search').value;
    if (search) params.append('search', search);
    
    const session = document.getElementById('filter-session').value;
    if (session) params.append('session_id', session);
    
    const who = document.getElementById('filter-who').value;
    if (who) params.append('who', who);
    
    const where = document.getElementById('filter-where').value;
    if (where) params.append('where', where);
    
    const entity = document.getElementById('filter-entity').value;
    if (entity) params.append('entity', entity);
    
    const dateFrom = document.getElementById('filter-date-from').value;
    if (dateFrom) params.append('date_from', dateFrom);
    
    const dateTo = document.getElementById('filter-date-to').value;
    if (dateTo) params.append('date_to', dateTo);
    
    // Show loading state
    const tbody = document.getElementById('memories-tbody');
    tbody.innerHTML = '<tr><td colspan="12" style="text-align: center;">Loading...</td></tr>';
    
    try {
        const response = await fetch('/api/memories?' + params);
        if (response.ok) {
            const data = await response.json();
            displayMemories(data.memories);
            updatePagination(data.pagination);
            
            // Update count
            document.getElementById('memory-count').textContent = 
                `(${data.pagination.total} total)`;
        }
    } catch (error) {
        console.error('Failed to load memories:', error);
        tbody.innerHTML = '<tr><td colspan="12" style="text-align: center; color: var(--synth-pink);">Failed to load memories</td></tr>';
    }
}

// Display memories in table
function displayMemories(memories) {
    const tbody = document.getElementById('memories-tbody');
    
    if (!memories || memories.length === 0) {
        tbody.innerHTML = '<tr><td colspan="12" class="table-loading">No memories found</td></tr>';
        return;
    }
    
    tbody.innerHTML = '';
    
    // Debug: Log first memory to see structure
    if (memories.length > 0) {
        console.log('First memory data:', memories[0]);
    }
    
    memories.forEach(memory => {
        const row = document.createElement('tr');
        if (selectedMemories.has(memory.memory_id)) {
            row.classList.add('selected');
        }
        
        row.innerHTML = `
            <td class="col-checkbox">
                <input type="checkbox" value="${memory.memory_id}" 
                       onchange="toggleSelection('${memory.memory_id}')" 
                       ${selectedMemories.has(memory.memory_id) ? 'checked' : ''} />
            </td>
            <td class="col-memory-id">
                <a class="memory-id-link" onclick="showMemoryDetails('${memory.memory_id}')">${memory.memory_id.substring(0, 12)}...</a>
            </td>
            <td>${memory.session_id || 'N/A'}</td>
            <td>${formatWhoList(memory.who_list, memory.who_type, memory.who_id)}</td>
            <td class="col-entities">${formatEntities(memory.entities)}</td>
            <td class="col-when">${formatWhenList(memory.when_list, memory.when_ts)}</td>
            <td>${formatWhereList(memory.where_list, memory.where_type, memory.where_value)}</td>
            <td title="${escapeHtml(memory.why || '')}">${truncateText(memory.why || 'N/A', 50)}</td>
            <td title="${escapeHtml(memory.how || '')}">${truncateText(memory.how || 'N/A', 50)}</td>
            <td class="col-score">${memory.token_count || 0}</td>
            <td class="col-text" title="${escapeHtml(memory.raw_text || '')}">${truncateText(memory.raw_text || '', 100)}</td>
            <td class="col-actions">
                <button onclick="showMemoryDetails('${memory.memory_id}')" class="btn-table">View</button>
                <button onclick="deleteMemory('${memory.memory_id}')" class="btn-table btn-danger">Delete</button>
            </td>
        `;
        
        // Add click handler for entire row (except checkbox and buttons)
        row.addEventListener('click', function(e) {
            // Don't trigger if clicking checkbox, button, or link
            if (!e.target.matches('input') && !e.target.matches('button') && !e.target.matches('a')) {
                showMemoryDetails(memory.memory_id);
            }
        });
        
        tbody.appendChild(row);
    });
}

// Update pagination controls
function updatePagination(pagination) {
    const topPag = document.getElementById('pagination-top');
    const bottomPag = document.getElementById('pagination-bottom');
    
    const pagHTML = `
        <button onclick="loadMemories(1)" ${!pagination.has_prev ? 'disabled' : ''}>First</button>
        <button onclick="loadMemories(${pagination.page - 1})" ${!pagination.has_prev ? 'disabled' : ''}>Previous</button>
        <span class="page-info">Page ${pagination.page} of ${pagination.total_pages}</span>
        <button onclick="loadMemories(${pagination.page + 1})" ${!pagination.has_next ? 'disabled' : ''}>Next</button>
        <button onclick="loadMemories(${pagination.total_pages})" ${!pagination.has_next ? 'disabled' : ''}>Last</button>
    `;
    
    topPag.innerHTML = pagHTML;
    bottomPag.innerHTML = pagHTML;
}

// Sort table by column
function sortTable(field) {
    // Update sort indicators
    const headers = document.querySelectorAll('.sortable');
    headers.forEach(header => {
        header.classList.remove('sort-asc', 'sort-desc');
    });
    
    // Toggle sort order if clicking same field
    if (currentSortField === field) {
        currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
    } else {
        currentSortField = field;
        currentSortOrder = 'desc';
    }
    
    // Update UI to show current sort
    const clickedHeader = event.currentTarget;
    if (clickedHeader) {
        clickedHeader.classList.add(currentSortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    // Update dropdown to match
    document.getElementById('sort-by').value = field;
    document.getElementById('sort-order').value = currentSortOrder;
    
    // Reload with new sort
    loadMemories(1);
}

// Apply filters
function applyFilters() {
    selectedMemories.clear();
    updateBulkActions();
    loadMemories(1);
}

// Clear all filters
function clearFilters() {
    document.getElementById('filter-search').value = '';
    document.getElementById('filter-session').value = '';
    document.getElementById('filter-who').value = '';
    document.getElementById('filter-where').value = '';
    document.getElementById('filter-entity').value = '';
    document.getElementById('filter-date-from').value = '';
    document.getElementById('filter-date-to').value = '';
    selectedMemories.clear();
    updateBulkActions();
    loadMemories(1);
}

// Toggle selection
function toggleSelection(memoryId) {
    if (selectedMemories.has(memoryId)) {
        selectedMemories.delete(memoryId);
    } else {
        selectedMemories.add(memoryId);
    }
    updateBulkActions();
}

// Toggle select all
function toggleSelectAll() {
    const checkboxes = document.querySelectorAll('#memories-tbody input[type="checkbox"]');
    const selectAll = document.getElementById('select-all').checked;
    
    checkboxes.forEach(cb => {
        cb.checked = selectAll;
        if (selectAll) {
            selectedMemories.add(cb.value);
        } else {
            selectedMemories.delete(cb.value);
        }
    });
    
    updateBulkActions();
}

// Update bulk actions display
function updateBulkActions() {
    const bulkActions = document.getElementById('bulk-actions');
    const selectedCount = document.getElementById('selected-count');
    
    if (selectedMemories.size > 0) {
        bulkActions.style.display = 'flex';
        selectedCount.textContent = `${selectedMemories.size} selected`;
    } else {
        bulkActions.style.display = 'none';
    }
}

// Delete single memory
async function deleteMemory(memoryId) {
    if (!confirm('Are you sure you want to delete this memory?')) return;
    
    // Show loading feedback on the delete button
    const deleteButtons = document.querySelectorAll(`button[onclick="deleteMemory('${memoryId}')"]`);
    deleteButtons.forEach(btn => {
        btn.disabled = true;
        btn.textContent = 'Deleting...';
    });
    
    try {
        const response = await fetch(`/api/memories/${memoryId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            // Remove from selected if it was selected
            selectedMemories.delete(memoryId);
            updateBulkActions();
            // Reload the current page
            loadMemories(currentPage);
        } else {
            const error = await response.json();
            showNotification('error', `Failed to delete memory: ${error.error || 'Unknown error'}`);
            // Restore button state
            deleteButtons.forEach(btn => {
                btn.disabled = false;
                btn.textContent = 'Delete';
            });
        }
    } catch (error) {
        console.error('Delete error:', error);
        showNotification('error', 'Failed to delete memory: ' + error.message);
        // Restore button state
        deleteButtons.forEach(btn => {
            btn.disabled = false;
            btn.textContent = 'Delete';
        });
    }
}

// Delete selected memories
async function deleteSelected() {
    if (selectedMemories.size === 0) return;
    
    if (!confirm(`Are you sure you want to delete ${selectedMemories.size} memories?`)) return;
    
    // Show loading state
    const bulkActions = document.getElementById('bulk-actions');
    const originalContent = bulkActions.innerHTML;
    bulkActions.innerHTML = '<span style="color: var(--synth-cyan);">Deleting memories...</span>';
    
    try {
        const response = await fetch('/api/memories/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                memory_ids: Array.from(selectedMemories)
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.failed_ids && result.failed_ids.length > 0) {
                showNotification('warning', `Deleted ${result.deleted_count} memories. Failed to delete ${result.failed_ids.length} memories.`);
            } else {
                // Success - clear selection and reload
                showNotification('success', `Successfully deleted ${selectedMemories.size} memories`);
                selectedMemories.clear();
                document.getElementById('select-all').checked = false;
            }
        } else {
            const error = await response.json();
            showNotification('error', `Failed to delete memories: ${error.error || 'Unknown error'}`);
        }
    } catch (error) {
        console.error('Delete error:', error);
        showNotification('error', 'Failed to delete memories: ' + error.message);
    } finally {
        // Restore original content and reload
        bulkActions.innerHTML = originalContent;
        updateBulkActions();
        loadMemories(currentPage);
    }
}

// Export memories based on current filters
async function exportMemories() {
    // Get current filter values
    const filters = {
        search: document.getElementById('filter-search').value,
        session_id: document.getElementById('filter-session').value,
        who: document.getElementById('filter-who').value,
        where: document.getElementById('filter-where').value,
        entity: document.getElementById('filter-entity').value,
        date_from: document.getElementById('filter-date-from').value,
        date_to: document.getElementById('filter-date-to').value
    };
    
    // Ask for format
    const format = confirm('Export as CSV? (OK for CSV, Cancel for JSON)') ? 'csv' : 'json';
    
    try {
        const response = await fetch('/api/memories/export', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                filters: filters,
                format: format
            })
        });
        
        if (response.ok) {
            // Create download link
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `memories_export_${new Date().toISOString().slice(0,10)}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } else {
            const error = await response.json();
            showNotification('error', `Failed to export memories: ${error.error || 'Unknown error'}`);
        }
    } catch (error) {
        console.error('Export error:', error);
        showNotification('error', 'Failed to export memories: ' + error.message);
    }
}

// Export selected memories
async function exportSelected() {
    if (selectedMemories.size === 0) {
        showNotification('warning', 'No memories selected for export');
        return;
    }
    
    // Ask for format
    const format = confirm('Export as CSV? (OK for CSV, Cancel for JSON)') ? 'csv' : 'json';
    
    try {
        const response = await fetch('/api/memories/export', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                memory_ids: Array.from(selectedMemories),
                format: format
            })
        });
        
        if (response.ok) {
            // Create download link
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `memories_export_selected_${new Date().toISOString().slice(0,10)}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } else {
            const error = await response.json();
            showNotification('error', `Failed to export memories: ${error.error || 'Unknown error'}`);
        }
    } catch (error) {
        console.error('Export error:', error);
        showNotification('error', 'Failed to export memories: ' + error.message);
    }
}

// Show memory details modal
async function showMemoryDetails(memoryId) {
    try {
        const response = await fetch(`/api/memories/${memoryId}`);
        if (!response.ok) {
            const error = await response.json();
            console.error('Failed to fetch memory:', error);
            showNotification('error', `Failed to load memory details: ${error.error || 'Unknown error'}`);
            return;
        }
        
        const memory = await response.json();
            
            const modal = document.getElementById('memory-modal');
            const details = document.getElementById('memory-details');
            
            // Format entities
            const entitiesHtml = memory.entities && memory.entities.length > 0
                ? `<div class="entity-list-modal">${memory.entities.map(e => 
                    `<span class="entity-tag" onclick="searchForEntity('${e}')">${e}</span>`
                  ).join('')}</div>`
                : '<span style="color: var(--synth-text-muted);">No entities extracted</span>';
            
            details.innerHTML = `
                <div class="memory-detail">
                    <div class="detail-section">
                        <h5>Memory Identifier</h5>
                        <div style="font-family: monospace; color: var(--synth-cyan); font-size: 1.1rem;">
                            ${memory.memory_id}
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h5>5W1H Components</h5>
                        <div class="detail-grid">
                            <div>
                                <strong>WHO:</strong> 
                                <span style="color: var(--synth-text);">
                                    ${formatWhoList(memory.who_list, memory.who_type, memory.who_id)}
                                    ${memory.who_label ? `<em>(${memory.who_label})</em>` : ''}
                                </span>
                            </div>
                            <div>
                                <strong>WHAT:</strong> 
                                <span style="color: var(--synth-text);" title="${escapeHtml(memory.what || '')}">
                                    ${truncateText(memory.what || 'N/A', 100)}
                                </span>
                            </div>
                            <div>
                                <strong>WHEN:</strong> 
                                <span style="color: var(--synth-text);">
                                    ${formatJsonList(memory.when_list, formatDate(memory.when_ts))}
                                </span>
                            </div>
                            <div>
                                <strong>WHERE:</strong> 
                                <span style="color: var(--synth-text);">
                                    ${formatWhereList(memory.where_list, memory.where_type, memory.where_value)}
                                </span>
                            </div>
                            <div>
                                <strong>WHY:</strong> 
                                <span style="color: var(--synth-text);">
                                    ${memory.why || 'N/A'}
                                </span>
                            </div>
                            <div>
                                <strong>HOW:</strong> 
                                <span style="color: var(--synth-text);">
                                    ${memory.how || 'N/A'}
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h5>What Items</h5>
                        ${entitiesHtml}
                    </div>
                    
                    <div class="detail-section">
                        <h5>Metadata</h5>
                        <div class="detail-grid">
                            <div><strong>SESSION:</strong> ${memory.session_id || 'N/A'}</div>
                            <div><strong>SOURCE EVENT:</strong> ${memory.source_event_id || 'N/A'}</div>
                            <div><strong>TOKEN COUNT:</strong> ${memory.token_count || 0}</div>
                            <div><strong>CREATED:</strong> ${formatDate(memory.created_at)}</div>
                            ${formatExtraJson(memory.extra_json)}
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h5>Raw Text</h5>
                        <div class="raw-text-display">
                            ${escapeHtml(memory.raw_text || 'No raw text available')}
                        </div>
                    </div>
                </div>
            `;
            
            modal.style.display = 'block';
    } catch (error) {
        console.error('Failed to load memory details:', error);
        showNotification('error', 'Failed to load memory details: ' + error.message);
    }
}

// Close modal
function closeModal() {
    document.getElementById('memory-modal').style.display = 'none';
}

// Search for entity
function searchForEntity(entity) {
    // Set the entity filter and apply
    document.getElementById('filter-entity').value = entity;
    applyFilters();
    // Close the modal
    closeModal();
}

// Helper functions
function formatEntities(entities) {
    if (!entities || entities.length === 0) return '';
    
    const maxShow = 3;
    const shown = entities.slice(0, maxShow);
    const html = shown.map(e => `<span class="entity-tag">${e}</span>`).join('');
    
    if (entities.length > maxShow) {
        return html + ` <small>+${entities.length - maxShow}</small>`;
    }
    return html;
}

function formatJsonList(jsonStr, fallbackValue) {
    try {
        if (!jsonStr) return fallbackValue || 'N/A';
        const list = JSON.parse(jsonStr);
        if (Array.isArray(list) && list.length > 0) {
            return list.join(', ');
        }
        return fallbackValue || 'N/A';
    } catch {
        return fallbackValue || jsonStr || 'N/A';
    }
}

function formatWhoList(whoList, whoType, whoId) {
    try {
        if (whoList) {
            const list = JSON.parse(whoList);
            if (Array.isArray(list) && list.length > 0) {
                return list.join(', ');
            }
        }
    } catch (e) {
        console.error('Error parsing who_list:', e, whoList);
    }
    // Fallback to old format
    if (whoType && whoId) {
        return `${whoType}:${whoId}`;
    }
    return 'N/A';
}

function formatWhenList(whenList, whenTs) {
    try {
        if (whenList) {
            const list = JSON.parse(whenList);
            if (Array.isArray(list) && list.length > 0) {
                // Format first date nicely, show count if more
                const firstDate = formatDate(list[0]);
                if (list.length > 1) {
                    return `${firstDate} (+${list.length - 1})`;
                }
                return firstDate;
            }
        }
    } catch {}
    // Fallback to when_ts
    return formatDate(whenTs);
}

function formatWhereList(whereList, whereType, whereValue) {
    try {
        if (whereList) {
            const list = JSON.parse(whereList);
            if (Array.isArray(list) && list.length > 0) {
                return list.join(', ');
            }
        }
    } catch {}
    // Fallback to old format
    if (whereType && whereValue) {
        return `${whereType}:${whereValue}`;
    }
    return 'N/A';
}

function formatDate(dateStr) {
    if (!dateStr) return 'N/A';
    try {
        const date = new Date(dateStr);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    } catch {
        return dateStr;
    }
}

function truncateText(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatExtraJson(extraJson) {
    if (!extraJson) return '';
    try {
        const data = JSON.parse(extraJson);
        let html = '';
        
        // Check for part information
        if (data.part_index !== undefined && data.total_parts !== undefined) {
            html += `<div><strong>PART:</strong> ${data.part_index} of ${data.total_parts}</div>`;
        }
        
        // Don't display embedding vectors
        if (data.embedding || data.embed || data.vector) {
            // Skip embedding data
            return html;
        }
        
        // Display any other relevant metadata
        for (const [key, value] of Object.entries(data)) {
            if (key !== 'part_index' && key !== 'total_parts' && 
                key !== 'embedding' && key !== 'embed' && key !== 'vector' &&
                value !== null && value !== undefined) {
                html += `<div><strong>${key.toUpperCase()}:</strong> ${value}</div>`;
            }
        }
        
        return html;
    } catch {
        return '';
    }
}

// Window click handler for modal
window.onclick = function(event) {
    const modal = document.getElementById('memory-modal');
    const importModal = document.getElementById('import-modal');
    if (event.target === modal) {
        modal.style.display = 'none';
    }
    if (event.target === importModal) {
        importModal.style.display = 'none';
    }
}

// Import functionality
let selectedFile = null;
let importJobs = [];
let importJobsInterval = null;

function showImportDialog() {
    document.getElementById('import-modal').style.display = 'block';
    loadImportJobs();
    // Start polling for job updates
    if (importJobsInterval) clearInterval(importJobsInterval);
    importJobsInterval = setInterval(loadImportJobs, 2000);
}

function closeImportModal() {
    document.getElementById('import-modal').style.display = 'none';
    // Stop polling
    if (importJobsInterval) {
        clearInterval(importJobsInterval);
        importJobsInterval = null;
    }
}

// File handling
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        selectedFile = file;
        displayFileInfo(file);
    }
}

function displayFileInfo(file) {
    document.getElementById('file-info').style.display = 'block';
    document.getElementById('file-name').textContent = file.name;
    document.getElementById('file-size').textContent = formatFileSize(file.size);
    
    let fileType = 'Unknown';
    if (file.name.endsWith('.json')) fileType = 'JSON';
    else if (file.name.endsWith('.csv')) fileType = 'CSV';
    else if (file.name.endsWith('.txt')) fileType = 'Text';
    
    document.getElementById('file-type').textContent = fileType;
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' bytes';
    else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
    else return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

// Drag and drop
const uploadArea = document.getElementById('file-upload-area');
if (uploadArea) {
    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });
    
    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('dragover');
    });
    
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        
        const file = e.dataTransfer.files[0];
        if (file) {
            selectedFile = file;
            displayFileInfo(file);
        }
    });
}

// Start import
async function startImport() {
    if (!selectedFile) {
        showNotification('warning', 'Please select a file to import');
        return;
    }
    
    const btn = document.getElementById('start-import-btn');
    btn.disabled = true;
    btn.textContent = 'Starting import...';
    
    try {
        const formData = new FormData();
        formData.append('file', selectedFile);
        
        const sessionId = document.getElementById('import-session-id').value;
        if (sessionId) {
            formData.append('session_id', sessionId);
        }
        
        const response = await fetch('/api/memories/import', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            
            // Reset form
            selectedFile = null;
            document.getElementById('import-file').value = '';
            document.getElementById('file-info').style.display = 'none';
            document.getElementById('import-session-id').value = '';
            
            // Reload jobs list
            loadImportJobs();
            
            // Show success
            showNotification('success', `Import job started! Job ID: ${result.job_id.substring(0, 8)}...`);
        } else {
            const error = await response.json();
            showNotification('error', `Failed to start import: ${error.error || 'Unknown error'}`);
        }
    } catch (error) {
        console.error('Import error:', error);
        showNotification('error', 'Failed to start import: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Start Import';
    }
}

// Track previous job statuses for completion detection
let previousJobStatuses = {};

// Load import jobs
async function loadImportJobs() {
    try {
        const response = await fetch('/api/import/jobs');
        if (response.ok) {
            const data = await response.json();
            
            // Check for newly completed jobs
            let hasNewlyCompleted = false;
            for (const job of data.jobs) {
                const prevStatus = previousJobStatuses[job.job_id];
                if (prevStatus === 'processing' && job.status === 'completed') {
                    hasNewlyCompleted = true;
                    // Show completion notification
                    showNotification('success', `Import job completed! ${job.successful_imports} records imported successfully.`);
                }
            }
            
            // Update previous statuses
            previousJobStatuses = {};
            for (const job of data.jobs) {
                previousJobStatuses[job.job_id] = job.status;
            }
            
            displayImportJobs(data.jobs);
            
            // Refresh memories list if any job just completed
            if (hasNewlyCompleted) {
                loadMemories(currentPage);
            }
        }
    } catch (error) {
        console.error('Failed to load import jobs:', error);
    }
}

// Display import jobs
function displayImportJobs(jobs) {
    const container = document.getElementById('import-jobs-list');
    
    if (!jobs || jobs.length === 0) {
        container.innerHTML = '<p style="color: var(--synth-text-muted);">No import jobs yet</p>';
        return;
    }
    
    container.innerHTML = jobs.map(job => {
        const statusClass = job.status.toLowerCase();
        const progressPercent = Math.round(job.progress_percentage || 0);
        
        return `
            <div class="import-job ${statusClass}">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Job ID:</strong> ${job.job_id.substring(0, 8)}...<br>
                        <strong>Status:</strong> <span style="color: ${getStatusColor(job.status)};">${job.status.toUpperCase()}</span><br>
                        <strong>Progress:</strong> ${job.processed_records}/${job.total_records} records
                    </div>
                    <div style="text-align: right;">
                        <strong>Success:</strong> ${job.successful_imports}<br>
                        <strong>Failed:</strong> ${job.failed_imports}<br>
                        <strong>Session:</strong> ${job.session_id || 'N/A'}
                    </div>
                </div>
                
                ${job.status === 'processing' ? `
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%;"></div>
                        <div class="progress-text">${progressPercent}%</div>
                    </div>
                ` : ''}
                
                ${job.error_messages && job.error_messages.length > 0 ? `
                    <div style="margin-top: 0.5rem; color: var(--synth-pink); font-size: 0.85rem;">
                        <strong>Errors:</strong><br>
                        ${job.error_messages.slice(0, 3).map(err => `‚Ä¢ ${err}`).join('<br>')}
                    </div>
                ` : ''}
                
                <div style="margin-top: 0.5rem; color: var(--synth-text-muted); font-size: 0.85rem;">
                    Started: ${formatDate(job.start_time)}
                    ${job.end_time ? `<br>Ended: ${formatDate(job.end_time)}` : ''}
                </div>
                
                ${job.status === 'processing' ? `
                    <button onclick="cancelImportJob('${job.job_id}')" class="btn-danger" style="margin-top: 0.5rem;">
                        Cancel Job
                    </button>
                ` : ''}
            </div>
        `;
    }).join('');
}

function getStatusColor(status) {
    switch(status.toLowerCase()) {
        case 'completed': return 'var(--synth-green)';
        case 'processing': return 'var(--synth-cyan)';
        case 'failed': return 'var(--synth-pink)';
        case 'cancelled': return 'var(--synth-text-muted)';
        default: return 'var(--synth-text)';
    }
}

// Cancel import job
async function cancelImportJob(jobId) {
    if (!confirm('Are you sure you want to cancel this import job?')) return;
    
    try {
        const response = await fetch(`/api/import/cancel/${jobId}`, {
            method: 'POST'
        });
        
        if (response.ok) {
            loadImportJobs();
        } else {
            const error = await response.json();
            showNotification('error', `Failed to cancel job: ${error.error || 'Unknown error'}`);
        }
    } catch (error) {
        console.error('Cancel error:', error);
        showNotification('error', 'Failed to cancel job: ' + error.message);
    }
}
</script>
{% endblock %}