{% extends "base.html" %}
{% block content %}
<div class="analytics-container">
    <!-- Overview Stats -->
    <div class="panel">
        <h3>System Overview</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="total-memories">-</div>
                <div class="stat-label">Total Memories</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="unique-sessions">-</div>
                <div class="stat-label">Unique Sessions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="unique-actors">-</div>
                <div class="stat-label">Unique Actors</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avg-tokens">-</div>
                <div class="stat-label">Avg Tokens/Memory</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="date-range">-</div>
                <div class="stat-label">Date Range</div>
            </div>
        </div>
    </div>
    
    <!-- Entity Analytics -->
    <div class="panel">
        <h3>Top What Items</h3>
        <div class="entity-controls">
            <button onclick="loadEntityAnalytics(500)" class="btn-secondary">Top 500</button>
            <button onclick="loadEntityAnalytics(1000)" class="btn-secondary">Top 1000</button>
            <button onclick="loadEntityAnalytics(5000)" class="btn-secondary">Top 5000</button>
        </div>
        <div id="top-entities" class="entity-list"></div>
    </div>
    
    <!-- Network Visualization - Separate Panel -->
    <div class="panel" style="margin-top: 20px;">
        <h3>5W1H Network Visualization</h3>
        <div class="network-controls" style="margin-bottom: 15px;">
            <button onclick="loadAndDrawNetwork('what')" class="network-btn active" data-type="what">What</button>
            <button onclick="loadAndDrawNetwork('who')" class="network-btn" data-type="who">Who</button>
            <button onclick="loadAndDrawNetwork('when')" class="network-btn" data-type="when">When</button>
            <button onclick="loadAndDrawNetwork('where')" class="network-btn" data-type="where">Where</button>
            <button onclick="loadAndDrawNetwork('why')" class="network-btn" data-type="why">Why</button>
            <button onclick="loadAndDrawNetwork('how')" class="network-btn" data-type="how">How</button>
        </div>
        <div id="network-container" style="width: 100%; height: 600px; background: #0a0814; border: 2px solid #00ffff; border-radius: 8px; position: relative; overflow: hidden;">
            <!-- Canvas will be created dynamically -->
        </div>
    </div>
    
    <!-- Temporal Analytics -->
    <div class="panel">
        <h3>Temporal Distribution</h3>
        <div class="temporal-controls">
            <button onclick="loadTemporalAnalytics(7)" class="btn-secondary">7 Days</button>
            <button onclick="loadTemporalAnalytics(30)" class="btn-secondary">30 Days</button>
            <button onclick="loadTemporalAnalytics(90)" class="btn-secondary">90 Days</button>
            <button onclick="loadTemporalAnalytics(3650)" class="btn-secondary">All Time</button>
        </div>
        
        <canvas id="temporal-chart" width="1200" height="400"></canvas>
        
        <div id="temporal-stats" class="temporal-stats"></div>
    </div>
    
    <!-- Score Analysis -->
    <div class="panel">
        <h3>Query Score Analysis</h3>
        <div class="score-section">
            <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                <input type="text" id="score-query" placeholder="Enter query to analyze..." style="flex: 1;" />
                <button onclick="analyzeScores()" class="btn-primary">Analyze</button>
            </div>
            
            <div class="analytics-grid">
                <div class="analytics-section">
                    <h4>Score Distribution</h4>
                    <canvas id="score-distribution" width="400" height="300"></canvas>
                </div>
                
                <div class="analytics-section">
                    <h4>Component Averages</h4>
                    <div id="component-averages"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.analytics-container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 1rem;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
}

.stat-card {
    background: var(--synth-surface);
    padding: 1.5rem;
    border-radius: 8px;
    border: 1px solid var(--synth-border);
    text-align: center;
    position: relative;
    overflow: hidden;
}

.stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
}

.stat-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--synth-cyan);
    text-shadow: 0 0 10px var(--synth-cyan);
    word-break: break-word;
    line-height: 1.2;
}

.stat-label {
    color: var(--synth-text-muted);
    text-transform: uppercase;
    font-size: 0.75rem;
    margin-top: 0.5rem;
}

.entity-controls,
.temporal-controls {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.analytics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

.analytics-section {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid var(--synth-border);
}

.analytics-section h4 {
    color: var(--synth-pink);
    margin-top: 0;
    margin-bottom: 1rem;
}

.entity-list {
    max-height: 400px;
    overflow-y: auto;
}

.entity-item {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem;
    border-bottom: 1px solid var(--synth-border);
    cursor: pointer;
    transition: background 0.3s;
}

.entity-item:hover {
    background: rgba(0, 255, 255, 0.1);
}

.entity-name {
    color: var(--synth-text);
    flex: 1;
}

.entity-count {
    color: var(--synth-cyan);
    font-weight: bold;
    margin-left: 1rem;
}

.entity-bar {
    height: 4px;
    background: linear-gradient(90deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
    margin-top: 0.25rem;
    border-radius: 2px;
}

.network-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background: var(--synth-surface);
    border-radius: 8px;
    border: 1px solid var(--synth-border);
}

.network-btn {
    padding: 0.4rem 0.8rem;
    background: transparent;
    color: var(--synth-text-muted);
    border: 1px solid transparent;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.network-btn:hover {
    color: var(--synth-cyan);
    border-color: var(--synth-cyan);
    text-shadow: 0 0 10px var(--synth-cyan);
}

.network-btn.active {
    background: linear-gradient(135deg, var(--synth-cyan) 0%, var(--synth-pink) 100%);
    color: var(--synth-dark-bg);
    font-weight: bold;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

.network-container {
    position: relative;
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid var(--synth-border);
}

.network-container canvas {
    display: block;
    margin: 0 auto;
    cursor: grab;
}

.network-container canvas:active {
    cursor: grabbing;
}

.network-tooltip {
    position: absolute;
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-cyan);
    border-radius: 4px;
    padding: 0.5rem;
    font-size: 0.8rem;
    pointer-events: none;
    z-index: 1000;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    max-width: 250px;
}

.temporal-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin-top: 1.5rem;
}

.temporal-stat {
    background: var(--synth-surface);
    padding: 1rem;
    border-radius: 4px;
    border: 1px solid var(--synth-border);
}

.component-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: var(--synth-surface);
    border-radius: 4px;
}

.component-name {
    color: var(--synth-cyan);
    font-weight: 600;
}

.component-value {
    color: var(--synth-text);
    font-family: monospace;
}

.component-visual {
    height: 4px;
    background: var(--synth-cyan);
    border-radius: 2px;
    margin-top: 0.25rem;
}

/* Remove generic canvas rule that breaks network visualization */
#temporal-chart, #score-distribution {
    max-width: 100%;
    height: auto;
}
</style>

<script>
// Load initial stats
document.addEventListener('DOMContentLoaded', function() {
    loadStats();
    loadEntityAnalytics(1000);
    loadTemporalAnalytics(30);
    // Initialize network with 'what' data
    loadAndDrawNetwork('what');
});

// Load system stats
async function loadStats() {
    try {
        const response = await fetch('/api/stats');
        if (response.ok) {
            const stats = await response.json();
            
            document.getElementById('total-memories').textContent = 
                stats.total_memories ? stats.total_memories.toLocaleString() : '0';
            document.getElementById('unique-sessions').textContent = 
                stats.unique_sessions ? stats.unique_sessions.toLocaleString() : '0';
            document.getElementById('unique-actors').textContent = 
                stats.unique_actors ? stats.unique_actors.toLocaleString() : '0';
            document.getElementById('avg-tokens').textContent = 
                stats.avg_tokens ? Math.round(stats.avg_tokens).toLocaleString() : '0';
            
            if (stats.date_range && stats.date_range.from && stats.date_range.to) {
                const from = new Date(stats.date_range.from).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: '2-digit'});
                const to = new Date(stats.date_range.to).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: '2-digit'});
                document.getElementById('date-range').textContent = `${from} - ${to}`;
            } else {
                document.getElementById('date-range').textContent = 'N/A';
            }
        }
    } catch (error) {
        console.error('Failed to load stats:', error);
    }
}

// Load entity analytics
async function loadEntityAnalytics(limit) {
    try {
        const response = await fetch(`/api/analytics/entities?limit=${limit}`);
        if (response.ok) {
            const data = await response.json();
            
            // Display top entities
            displayTopEntities(data.top_entities);
            
            // Initialize and draw network with 'what' data
            if (!networkGraph) {
                networkGraph = new NetworkGraph('network-container');
            }
            networkGraph.setData(data.co_occurrence || [], 'what');
        }
    } catch (error) {
        console.error('Failed to load entity analytics:', error);
    }
}

// Display top entities
function displayTopEntities(entities) {
    const container = document.getElementById('top-entities');
    
    if (!entities || entities.length === 0) {
        container.innerHTML = '<p style="color: var(--synth-text-muted);">No entities found</p>';
        return;
    }
    
    const maxCount = entities[0][1];
    
    container.innerHTML = '';
    entities.slice(0, 30).forEach(([entity, count]) => {
        const item = document.createElement('div');
        item.className = 'entity-item';
        item.onclick = () => searchForEntity(entity);
        
        const barWidth = (count / maxCount) * 100;
        
        item.innerHTML = `
            <span class="entity-name">${entity}</span>
            <span class="entity-count">${count}</span>
            <div class="entity-bar" style="width: ${barWidth}%;"></div>
        `;
        
        container.appendChild(item);
    });
}

// Simple, clean network visualization
class NetworkGraph {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.nodes = [];
        this.links = [];
        this.canvas = null;
        this.ctx = null;
        this.width = 0;
        this.height = 0;
        this.currentType = 'what';
        this.isDragging = false;
        this.draggedNode = null;
        this.mouseX = 0;
        this.mouseY = 0;
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.isPanning = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        
        this.init();
    }
    
    init() {
        // Clear container and create fresh canvas
        this.container.innerHTML = '';
        this.canvas = document.createElement('canvas');
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.cursor = 'grab';
        this.container.appendChild(this.canvas);
        
        // Set canvas size
        this.resize();
        
        // Get context
        this.ctx = this.canvas.getContext('2d');
        
        // Setup event listeners
        this.setupEvents();
        
        // Handle resize
        window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
        const rect = this.container.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }
    
    setupEvents() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.onMouseUp());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
    }
    
    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - this.offsetX) / this.zoom;
        const y = (e.clientY - rect.top - this.offsetY) / this.zoom;
        
        // Store initial mouse position for panning
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.isPanning = false;
        
        // Check if clicking on a node
        for (let node of this.nodes) {
            const dist = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
            if (dist < node.radius) {
                this.isDragging = true;
                this.draggedNode = node;
                this.canvas.style.cursor = 'grabbing';
                return;
            }
        }
        
        // If not clicking on a node, prepare for panning
        this.isPanning = true;
        this.canvas.style.cursor = 'grabbing';
    }
    
    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = (e.clientX - rect.left - this.offsetX) / this.zoom;
        this.mouseY = (e.clientY - rect.top - this.offsetY) / this.zoom;
        
        if (this.isDragging && this.draggedNode) {
            this.draggedNode.x = this.mouseX;
            this.draggedNode.y = this.mouseY;
            this.draw();
        } else if (this.isPanning) {
            // Calculate pan offset
            const deltaX = e.clientX - this.lastMouseX;
            const deltaY = e.clientY - this.lastMouseY;
            
            this.offsetX += deltaX;
            this.offsetY += deltaY;
            
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            
            this.draw();
        }
    }
    
    onMouseUp() {
        this.isDragging = false;
        this.draggedNode = null;
        this.isPanning = false;
        this.canvas.style.cursor = 'grab';
    }
    
    onWheel(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate zoom
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.3, Math.min(5, this.zoom * delta));
        
        // Calculate offset to zoom towards mouse position
        const scaleChange = newZoom - this.zoom;
        this.offsetX -= mouseX * scaleChange;
        this.offsetY -= mouseY * scaleChange;
        
        this.zoom = newZoom;
        this.draw();
    }
    
    setData(coOccurrenceData, type) {
        this.currentType = type;
        this.nodes = [];
        this.links = [];
        
        if (!coOccurrenceData || coOccurrenceData.length === 0) {
            this.draw();
            return;
        }
        
        // Build node map
        const nodeMap = {};
        coOccurrenceData.forEach(link => {
            if (!nodeMap[link.source]) {
                nodeMap[link.source] = { 
                    id: link.source, 
                    x: 0, 
                    y: 0, 
                    radius: 10,
                    weight: 0 
                };
            }
            if (!nodeMap[link.target]) {
                nodeMap[link.target] = { 
                    id: link.target, 
                    x: 0, 
                    y: 0, 
                    radius: 10,
                    weight: 0 
                };
            }
            nodeMap[link.source].weight += link.weight;
            nodeMap[link.target].weight += link.weight;
        });
        
        // Convert to array and position in circle
        this.nodes = Object.values(nodeMap);
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const radius = Math.min(this.width, this.height) * 0.3;
        
        this.nodes.forEach((node, i) => {
            const angle = (i / this.nodes.length) * 2 * Math.PI;
            node.x = centerX + Math.cos(angle) * radius;
            node.y = centerY + Math.sin(angle) * radius;
            node.radius = Math.min(8 + node.weight * 2, 25);
        });
        
        // Build links
        this.links = coOccurrenceData.map(link => ({
            source: nodeMap[link.source],
            target: nodeMap[link.target],
            weight: link.weight
        }));
        
        this.draw();
    }
    
    draw() {
        if (!this.ctx) return;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        // Dark background
        this.ctx.fillStyle = '#0a0814';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        // Save context state
        this.ctx.save();
        
        // Apply zoom and offset transformations
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.zoom, this.zoom);
        
        // Draw grid
        this.drawGrid();
        
        // Draw links
        this.ctx.strokeStyle = '#00ffff30';  // Cyan with transparency
        this.links.forEach(link => {
            this.ctx.lineWidth = Math.min(link.weight * 0.5, 3);
            this.ctx.beginPath();
            this.ctx.moveTo(link.source.x, link.source.y);
            this.ctx.lineTo(link.target.x, link.target.y);
            this.ctx.stroke();
        });
        
        // Draw nodes
        this.nodes.forEach(node => {
            // Node circle
            this.ctx.fillStyle = this.getNodeColor(this.currentType);
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
            this.ctx.fill();
            
            // Node border
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            // Node label
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = '12px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(node.id.substring(0, 20), node.x, node.y - node.radius - 5);
        });
        
        // Restore context state
        this.ctx.restore();
        
        // Draw info (not affected by zoom)
        this.ctx.fillStyle = '#00ffff';
        this.ctx.font = '12px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`${this.currentType.toUpperCase()} Network: ${this.nodes.length} nodes, ${this.links.length} links | Zoom: ${(this.zoom * 100).toFixed(0)}%`, 10, 20);
    }
    
    drawGrid() {
        this.ctx.strokeStyle = '#00ffff10';  // Very faint cyan
        this.ctx.lineWidth = 1;
        
        // Calculate visible area in world coordinates
        const startX = -this.offsetX / this.zoom;
        const startY = -this.offsetY / this.zoom;
        const endX = (this.width - this.offsetX) / this.zoom;
        const endY = (this.height - this.offsetY) / this.zoom;
        
        // Vertical lines
        const gridSize = 50;
        for (let x = Math.floor(startX / gridSize) * gridSize; x < endX; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, endY);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = Math.floor(startY / gridSize) * gridSize; y < endY; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(endX, y);
            this.ctx.stroke();
        }
    }
    
    getNodeColor(type) {
        const colors = {
            what: '#00ffff',   // cyan
            who: '#ff00ff',    // magenta
            when: '#ffff00',   // yellow
            where: '#00ff00',  // green
            why: '#ff8800',    // orange
            how: '#8800ff'     // purple
        };
        return colors[type] || '#00ffff';
    }
}

// Global network instance
let networkGraph = null;

// Load and draw network
async function loadAndDrawNetwork(type) {
    // Update button states
    document.querySelectorAll('.network-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
    });
    
    // Initialize network if needed
    if (!networkGraph) {
        networkGraph = new NetworkGraph('network-container');
    }
    
    try {
        // Load data from API
        const response = await fetch(`/api/analytics/network/${type}`);
        if (response.ok) {
            const data = await response.json();
            networkGraph.setData(data.co_occurrence || [], type);
        } else {
            console.error('Failed to load network data');
            networkGraph.setData([], type);
        }
    } catch (error) {
        console.error('Error loading network:', error);
        networkGraph.setData([], type);
    }
}

// REMOVED OLD NETWORK CODE - Using NetworkGraph class instead
// Old drawEntityNetwork function removed
function OLD_drawEntityNetwork(coOccurrence, networkType = 'what') {
    console.log(`Drawing network for type: ${networkType}`);
    console.log(`Co-occurrence data:`, coOccurrence);
    
    const canvas = document.getElementById('entity-network');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    
    // Get the actual displayed size of the canvas
    const rect = canvas.getBoundingClientRect();
    
    // Set canvas internal size to match its display size
    canvas.width = rect.width;
    canvas.height = rect.height;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('Could not get canvas context!');
        return;
    }
    
    console.log(`Canvas dimensions: ${canvas.width}x${canvas.height}`);
    
    // Clear any existing animation
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    
    if (!coOccurrence || coOccurrence.length === 0) {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Fill with dark background
        ctx.fillStyle = 'rgba(10, 10, 30, 0.95)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#888888';  // Gray text
        ctx.font = '14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`No ${networkType} co-occurrence data`, canvas.width/2, canvas.height/2);
        return;
    }
    
    // Initialize nodes with physics properties
    networkNodes = {};
    networkLinks = [];
    
    // Position nodes in a circle initially for better visibility
    const nodeArray = [];
    const uniqueNodes = new Set();
    
    coOccurrence.forEach(link => {
        uniqueNodes.add(link.source);
        uniqueNodes.add(link.target);
    });
    
    const nodeCount = uniqueNodes.size;
    const angleStep = (2 * Math.PI) / nodeCount;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) * 0.35; // Use 35% of canvas size
    
    let index = 0;
    uniqueNodes.forEach(nodeName => {
        const angle = index * angleStep;
        networkNodes[nodeName] = {
            id: nodeName,
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius,
            vx: 0,
            vy: 0,
            connections: 0,
            weight: 0
        };
        index++;
    });
    
    // Now process the links
    coOccurrence.forEach(link => {
        
        networkNodes[link.source].connections++;
        networkNodes[link.target].connections++;
        networkNodes[link.source].weight += link.weight;
        networkNodes[link.target].weight += link.weight;
        
        networkLinks.push({
            source: networkNodes[link.source],
            target: networkNodes[link.target],
            weight: link.weight
        });
    });
    
    // Log initial node positions for debugging
    console.log(`Initialized ${Object.keys(networkNodes).length} nodes`);
    const sampleNodes = Object.values(networkNodes).slice(0, 3);
    sampleNodes.forEach(node => {
        console.log(`Node ${node.id}: position (${node.x.toFixed(0)}, ${node.y.toFixed(0)})`);
    });
    
    // Set up mouse event handlers
    setupNetworkInteraction(canvas);
    
    // Draw the network ONCE without animation for now
    drawNetworkFrame(ctx, canvas, networkType);
    
    // Comment out animation for debugging
    // setTimeout(() => {
    //     animateNetwork(ctx, canvas, networkType);
    // }, 100);
}

// Draw a single frame of the network (extracted from animateNetwork)
function drawNetworkFrame(ctx, canvas, networkType) {
    // Clear the canvas first
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw a subtle grid background instead of solid black
    drawGridBackground(ctx, canvas.width, canvas.height);
    
    // Debug logging (only log once)
    const nodeCount = Object.keys(networkNodes).length;
    const linkCount = networkLinks.length;
    if (!window.networkDebugLogged) {
        console.log(`Drawing frame - Nodes: ${nodeCount}, Links: ${linkCount}`);
        window.networkDebugLogged = true;
    }
    
    if (nodeCount === 0) {
        console.error('No nodes to draw!');
        ctx.fillStyle = '#ff0000';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ERROR: No nodes loaded', canvas.width/2, canvas.height/2);
        return;
    }
    
    // Get color scheme for network type
    const colors = getNetworkColors(networkType);
    
    // Draw links with HIGH VISIBILITY
    let linksDrawn = 0;
    networkLinks.forEach(link => {
        if (!link.source || !link.target) {
            console.error('Invalid link:', link);
            return;
        }
        
        // Simple bright yellow lines
        ctx.strokeStyle = '#ffff00';  // Bright yellow
        ctx.lineWidth = Math.max(1, Math.min(link.weight || 1, 3));
        ctx.globalAlpha = 0.7;
        
        ctx.beginPath();
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
        ctx.stroke();
        
        ctx.globalAlpha = 1;
        linksDrawn++;
    });
    
    // Draw nodes with HIGH VISIBILITY
    let nodesDrawn = 0;
    Object.values(networkNodes).forEach((node, index) => {
        if (!node || typeof node.x !== 'number' || typeof node.y !== 'number') {
            console.error('Invalid node:', node);
            return;
        }
        
        // Log first few nodes for debugging
        if (index < 3) {
            console.log(`Drawing node ${node.id} at (${node.x.toFixed(1)}, ${node.y.toFixed(1)}), color: ${colors.nodeBase || '#00ffff'}`);
        }
        
        const radius = Math.min(10 + (node.weight || 0) * 2, 25);
        
        // Draw a TEST RECTANGLE first to make sure drawing works
        ctx.fillStyle = '#ff00ff';  // Bright magenta for visibility
        ctx.fillRect(node.x - 5, node.y - 5, 10, 10);
        
        // Simple bright solid color node
        ctx.fillStyle = '#00ffff';  // Force bright cyan
        ctx.beginPath();
        ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Bright border
        ctx.strokeStyle = '#ffff00';  // Yellow border for visibility
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Label with white text (skip background for now)
        const label = (node.id || 'Unknown').substring(0, 15);
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(label, node.x, node.y - radius - 10);
        
        nodesDrawn++;
    });
    
    // Debug: Show node and link count
    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
    ctx.font = '12px "Courier New", monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Nodes: ${nodeCount} (${nodesDrawn} drawn), Links: ${linkCount} (${linksDrawn} drawn)`, 10, canvas.height - 10);
}

// Draw synthwave grid background
function drawGridBackground(ctx, width, height) {
    // Create gradient background with synthwave colors
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, 'rgba(10, 8, 20, 0.95)');  // Dark purple-black
    gradient.addColorStop(1, 'rgba(20, 16, 31, 0.95)');  // Slightly lighter
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';  // Cyan grid
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }
    
    // Horizontal lines with perspective
    for (let y = 0; y <= height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
}

// Setup mouse interaction for network
function setupNetworkInteraction(canvas) {
    // Remove existing listeners
    const newCanvas = canvas.cloneNode(true);
    canvas.parentNode.replaceChild(newCanvas, canvas);
    const updatedCanvas = document.getElementById('entity-network');
    
    // Add zoom functionality
    let zoomLevel = 1.0;
    updatedCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomLevel *= delta;
        zoomLevel = Math.max(0.5, Math.min(3.0, zoomLevel));
        
        // Apply zoom to all nodes
        const centerX = updatedCanvas.width / 2;
        const centerY = updatedCanvas.height / 2;
        
        Object.values(networkNodes).forEach(node => {
            // Zoom relative to center
            node.x = centerX + (node.x - centerX) * delta;
            node.y = centerY + (node.y - centerY) * delta;
        });
        
        console.log(`Zoom level: ${zoomLevel.toFixed(2)}`);
    });
    
    updatedCanvas.addEventListener('mousedown', (e) => {
        const rect = updatedCanvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        
        // Check if clicking on a node
        Object.values(networkNodes).forEach(node => {
            const dist = Math.sqrt(Math.pow(node.x - mousePos.x, 2) + Math.pow(node.y - mousePos.y, 2));
            const radius = Math.min(8 + node.weight, 20);
            if (dist <= radius) {
                isDragging = true;
                draggedNode = node;
                updatedCanvas.style.cursor = 'grabbing';
            }
        });
    });
    
    updatedCanvas.addEventListener('mousemove', (e) => {
        const rect = updatedCanvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        
        if (isDragging && draggedNode) {
            draggedNode.x = mousePos.x;
            draggedNode.y = mousePos.y;
            draggedNode.vx = 0;
            draggedNode.vy = 0;
        } else {
            // Check if hovering over a node
            let hovering = false;
            Object.values(networkNodes).forEach(node => {
                const dist = Math.sqrt(Math.pow(node.x - mousePos.x, 2) + Math.pow(node.y - mousePos.y, 2));
                const radius = Math.min(8 + node.weight, 20);
                if (dist <= radius) {
                    hovering = true;
                    showNetworkTooltip(node, e.clientX, e.clientY);
                }
            });
            
            if (!hovering) {
                hideNetworkTooltip();
            }
            
            updatedCanvas.style.cursor = hovering ? 'grab' : 'default';
        }
    });
    
    updatedCanvas.addEventListener('mouseup', () => {
        isDragging = false;
        draggedNode = null;
        updatedCanvas.style.cursor = 'default';
    });
    
    updatedCanvas.addEventListener('mouseleave', () => {
        isDragging = false;
        draggedNode = null;
        hideNetworkTooltip();
        updatedCanvas.style.cursor = 'default';
    });
}

// Show tooltip for network node
function showNetworkTooltip(node, x, y) {
    const tooltip = document.getElementById('network-tooltip');
    if (tooltip) {
        tooltip.innerHTML = `
            <strong>${node.id}</strong><br>
            Connections: ${node.connections}<br>
            Weight: ${node.weight.toFixed(1)}
        `;
        tooltip.style.left = `${x + 10}px`;
        tooltip.style.top = `${y - 30}px`;
        tooltip.style.display = 'block';
    }
}

// Hide network tooltip
function hideNetworkTooltip() {
    const tooltip = document.getElementById('network-tooltip');
    if (tooltip) {
        tooltip.style.display = 'none';
    }
}

// Animate network with physics
function animateNetwork(ctx, canvas, networkType) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const damping = 0.92;  // Slightly more damping to stabilize
    const repulsion = 1500;  // Reduced repulsion force
    const attraction = 0.005;  // Increased attraction to keep connected nodes closer
    
    // Apply physics forces
    Object.values(networkNodes).forEach(node => {
        if (isDragging && node === draggedNode) return;
        
        // Reset forces
        let fx = 0, fy = 0;
        
        // Repulsion between nodes
        Object.values(networkNodes).forEach(other => {
            if (node === other) return;
            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0 && dist < 200) {
                const force = repulsion / (dist * dist);
                fx += (dx / dist) * force;
                fy += (dy / dist) * force;
            }
        });
        
        // Attraction along links
        networkLinks.forEach(link => {
            let other = null;
            if (link.source === node) other = link.target;
            if (link.target === node) other = link.source;
            
            if (other) {
                const dx = other.x - node.x;
                const dy = other.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const force = dist * attraction * link.weight;
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                }
            }
        });
        
        // Center gravity - stronger to keep nodes in view
        fx += (centerX - node.x) * 0.001;
        fy += (centerY - node.y) * 0.001;
        
        // Update velocity
        node.vx = (node.vx + fx) * damping;
        node.vy = (node.vy + fy) * damping;
        
        // Update position
        node.x += node.vx;
        node.y += node.vy;
        
        // Keep within bounds
        node.x = Math.max(20, Math.min(canvas.width - 20, node.x));
        node.y = Math.max(20, Math.min(canvas.height - 20, node.y));
    });
    
    // Draw the current frame
    drawNetworkFrame(ctx, canvas, networkType);
    
    // Continue animation
    animationFrame = requestAnimationFrame(() => animateNetwork(ctx, canvas, networkType));
}

// Get color scheme for network type
function getNetworkColors(type) {
    const schemes = {
        what: {
            nodeBase: '#00ffff',
            nodeHighlight: '#80ffff',
            nodeCenter: 'rgba(0, 255, 255, 0.3)',
            nodeMid: 'rgba(0, 255, 255, 0.1)',
            nodeBorder: '#00cccc',
            linkStart: 'rgba(0, 255, 255, 0.6)',
            linkEnd: 'rgba(0, 200, 200, 0.3)',
            glow: '#00ffff',
            text: '#00ffff'
        },
        who: {
            nodeBase: '#ff00ff',
            nodeHighlight: '#ff80ff',
            nodeCenter: 'rgba(255, 0, 255, 0.3)',
            nodeMid: 'rgba(255, 0, 255, 0.1)',
            nodeBorder: '#cc00cc',
            linkStart: 'rgba(255, 0, 255, 0.6)',
            linkEnd: 'rgba(200, 0, 200, 0.3)',
            glow: '#ff00ff',
            text: '#ff00ff'
        },
        when: {
            nodeBase: '#ffff00',
            nodeHighlight: '#ffff80',
            nodeCenter: 'rgba(255, 255, 0, 0.3)',
            nodeMid: 'rgba(255, 255, 0, 0.1)',
            nodeBorder: '#cccc00',
            linkStart: 'rgba(255, 255, 0, 0.6)',
            linkEnd: 'rgba(200, 200, 0, 0.3)',
            glow: '#ffff00',
            text: '#ffff00'
        },
        where: {
            nodeBase: '#00ff00',
            nodeHighlight: '#80ff80',
            nodeCenter: 'rgba(0, 255, 0, 0.3)',
            nodeMid: 'rgba(0, 255, 0, 0.1)',
            nodeBorder: '#00cc00',
            linkStart: 'rgba(0, 255, 0, 0.6)',
            linkEnd: 'rgba(0, 200, 0, 0.3)',
            glow: '#00ff00',
            text: '#00ff00'
        },
        why: {
            nodeBase: '#ff8800',
            nodeHighlight: '#ffaa44',
            nodeCenter: 'rgba(255, 136, 0, 0.3)',
            nodeMid: 'rgba(255, 136, 0, 0.1)',
            nodeBorder: '#cc6600',
            linkStart: 'rgba(255, 136, 0, 0.6)',
            linkEnd: 'rgba(200, 100, 0, 0.3)',
            glow: '#ff8800',
            text: '#ff8800'
        },
        how: {
            nodeBase: '#8800ff',
            nodeHighlight: '#aa44ff',
            nodeCenter: 'rgba(136, 0, 255, 0.3)',
            nodeMid: 'rgba(136, 0, 255, 0.1)',
            nodeBorder: '#6600cc',
            linkStart: 'rgba(136, 0, 255, 0.6)',
            linkEnd: 'rgba(100, 0, 200, 0.3)',
            glow: '#8800ff',
            text: '#8800ff'
        }
    };
    
    return schemes[type] || schemes.what;
}

// Load temporal analytics
async function loadTemporalAnalytics(days) {
    try {
        const response = await fetch(`/api/analytics/temporal?days=${days}`);
        if (response.ok) {
            const data = await response.json();
            drawTemporalChart(data.timeline);
            displayTemporalStats(data.timeline);
        }
    } catch (error) {
        console.error('Failed to load temporal analytics:', error);
    }
}

// Draw temporal chart
function drawTemporalChart(timeline) {
    const canvas = document.getElementById('temporal-chart');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!timeline || timeline.length === 0) {
        // Fill background
        ctx.fillStyle = 'rgba(10, 10, 30, 0.95)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#888888';  // Gray text
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No temporal data', canvas.width/2, canvas.height/2);
        return;
    }
    
    const padding = 60;  // Increased padding for labels
    const bottomPadding = 100;  // Extra padding for date labels
    const chartWidth = canvas.width - 2 * padding;
    const chartHeight = canvas.height - padding - bottomPadding;
    const barWidth = chartWidth / timeline.length;
    
    const maxCount = Math.max(...timeline.map(t => t.memories));
    
    // Fill background with synthwave gradient
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, 'rgba(10, 8, 20, 0.98)');
    bgGradient.addColorStop(1, 'rgba(20, 16, 31, 0.98)');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    ctx.lineWidth = 0.5;
    // Horizontal grid lines
    for (let i = 0; i <= 5; i++) {
        const y = padding + (chartHeight * i / 5);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(canvas.width - padding, y);
        ctx.stroke();
    }
    
    // Draw axes with glow effect
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - bottomPadding);
    ctx.lineTo(canvas.width - padding, canvas.height - bottomPadding);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Y-axis labels
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 11px "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let i = 0; i <= 5; i++) {
        const value = Math.round(maxCount * (5 - i) / 5);
        const y = padding + (chartHeight * i / 5);
        ctx.fillText(value.toString(), padding - 10, y);
    }
    
    // Draw bars
    timeline.forEach((day, index) => {
        const barHeight = (day.memories / maxCount) * chartHeight;
        const x = padding + index * barWidth;
        const y = canvas.height - bottomPadding - barHeight;
        
        // Bar with synthwave gradient
        const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
        gradient.addColorStop(0, '#ff00ff');
        gradient.addColorStop(0.5, '#00ffff');
        gradient.addColorStop(1, '#0088aa');
        ctx.fillStyle = gradient;
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        
        // Bar glow effect
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 5;
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 2, y, barWidth - 4, barHeight);
        ctx.shadowBlur = 0;
        
        // Date label (show more frequently based on timeline length)
        const labelFrequency = Math.max(1, Math.floor(timeline.length / 10));
        if (index % labelFrequency === 0 || index === timeline.length - 1) {
            // Date label background for better readability
            ctx.save();
            ctx.translate(x + barWidth/2, canvas.height - bottomPadding + 25);
            ctx.rotate(-Math.PI/6);  // Less rotation for better readability
            
            // Background box
            const dateText = day.date;
            ctx.font = 'bold 11px "Courier New", monospace';
            const textWidth = ctx.measureText(dateText).width;
            ctx.fillStyle = 'rgba(10, 8, 20, 0.9)';
            ctx.fillRect(-textWidth - 5, -12, textWidth + 10, 18);
            
            // Date text with glow
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 8;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(dateText, 0, 0);
            ctx.restore();
            ctx.shadowBlur = 0;
        }
        
        // Value label on top of bar for significant values
        if (day.memories > maxCount * 0.7) {
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 10px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(day.memories.toString(), x + barWidth/2, y - 3);
        }
    });
    
    // Title with synthwave style
    ctx.fillStyle = '#ff00ff';
    ctx.font = 'bold 16px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 10;
    ctx.fillText('TEMPORAL DISTRIBUTION', canvas.width/2, 10);
    ctx.shadowBlur = 0;
    
    // X-axis label
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 12px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('DATE', canvas.width/2, canvas.height - 10);
    
    // Y-axis label
    ctx.save();
    ctx.translate(15, canvas.height/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('MEMORIES', 0, 0);
    ctx.restore();
}

// Display temporal stats
function displayTemporalStats(timeline) {
    const container = document.getElementById('temporal-stats');
    
    if (!timeline || timeline.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    const totalMemories = timeline.reduce((sum, day) => sum + day.memories, 0);
    const avgPerDay = totalMemories / timeline.length;
    const maxDay = timeline.reduce((max, day) => day.memories > max.memories ? day : max);
    const totalSessions = timeline.reduce((sum, day) => sum + day.sessions, 0);
    
    container.innerHTML = `
        <div class="temporal-stat">
            <div class="stat-label">Total Period</div>
            <div class="stat-value">${timeline.length} days</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Avg Memories/Day</div>
            <div class="stat-value">${Math.round(avgPerDay)}</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Peak Day</div>
            <div class="stat-value">${maxDay.date}<br>${maxDay.memories} memories</div>
        </div>
        <div class="temporal-stat">
            <div class="stat-label">Total Sessions</div>
            <div class="stat-value">${totalSessions}</div>
        </div>
    `;
}

// Analyze scores for a query
async function analyzeScores() {
    const query = document.getElementById('score-query').value.trim();
    if (!query) {
        alert('Please enter a query to analyze');
        return;
    }
    
    try {
        // Get current weights from analyzer
        const weightsResponse = await fetch('/api/weights');
        const weights = await weightsResponse.json();
        
        const response = await fetch('/api/analytics/scores', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                weights: weights
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            drawScoreDistribution(data.score_distribution);
            displayComponentAverages(data.component_averages);
        }
    } catch (error) {
        console.error('Failed to analyze scores:', error);
    }
}

// Draw score distribution
function drawScoreDistribution(distribution) {
    const canvas = document.getElementById('score-distribution');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const labels = Object.keys(distribution);
    const values = Object.values(distribution);
    const maxValue = Math.max(...values, 1);
    
    const barWidth = canvas.width / labels.length;
    const chartHeight = canvas.height - 40;
    
    // Draw bars
    labels.forEach((label, index) => {
        const barHeight = (values[index] / maxValue) * chartHeight;
        const x = index * barWidth;
        const y = canvas.height - barHeight - 20;
        
        // Bar
        ctx.fillStyle = '#00ffff';  // Cyan color
        ctx.fillRect(x + 5, y, barWidth - 10, barHeight);
        
        // Label
        ctx.fillStyle = '#ffffff';  // White text
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + barWidth/2, canvas.height - 5);
        
        // Count
        if (values[index] > 0) {
            ctx.fillText(values[index].toString(), x + barWidth/2, y - 5);
        }
    });
    
    // Title
    ctx.fillStyle = '#ffffff';  // White text
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Score Distribution', canvas.width/2, 15);
}

// Display component averages
function displayComponentAverages(averages) {
    const container = document.getElementById('component-averages');
    
    container.innerHTML = '';
    Object.entries(averages).forEach(([component, avg]) => {
        const bar = document.createElement('div');
        bar.className = 'component-bar';
        
        const width = avg * 100;
        
        bar.innerHTML = `
            <span class="component-name">${component}</span>
            <span class="component-value">${avg.toFixed(3)}</span>
            <div class="component-visual" style="width: ${width}%;"></div>
        `;
        
        container.appendChild(bar);
    });
}

// Search for entity in analyzer
function searchForEntity(entity) {
    // Navigate to analyzer with entity as query
    window.location.href = `/?query=${encodeURIComponent(entity)}`;
}
</script>
{% endblock %}