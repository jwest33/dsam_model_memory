{% extends "base.html" %}

{% block title %}JAM Chat Interface - Memory Enhanced{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/modal.css') }}">
<style>
.chat-container {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 120px);
    max-width: 1800px;
    margin: 0 auto;
    padding: 1rem;
    width: 95%;
}

.chat-header {
    display: flex;
    gap: 1rem;
    align-items: center;
    padding: 1rem;
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-border);
    border-radius: 8px;
    margin-bottom: 1rem;
    box-shadow: 0 2px 10px rgba(0, 255, 255, 0.1);
}

/* Memory Search Toggle Section */
.memory-toggle-section {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1rem;
    background: linear-gradient(135deg, 
        rgba(168, 85, 247, 0.1) 0%, 
        rgba(0, 255, 255, 0.1) 100%);
    border: 1px solid var(--synth-purple);
    border-radius: 8px;
    margin-left: auto;
}

.memory-toggle-label {
    color: var(--synth-cyan);
    font-size: 0.875rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.toggle-switch {
    position: relative;
    width: 60px;
    height: 28px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--synth-surface);
    transition: 0.4s;
    border-radius: 34px;
    border: 1px solid var(--synth-border);
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 3px;
    background: var(--synth-text-muted);
    transition: 0.4s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background: linear-gradient(135deg, var(--synth-purple), var(--synth-cyan));
    border-color: var(--synth-cyan);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

input:checked + .toggle-slider:before {
    transform: translateX(32px);
    background: white;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
}

.memory-status {
    font-size: 0.75rem;
    color: var(--synth-green);
    opacity: 0;
    transition: opacity 0.3s;
}

.memory-status.active {
    opacity: 1;
    animation: pulse 2s infinite;
}

/* Main Content Area */
.chat-main {
    display: flex;
    gap: 0;
    flex: 1;
    overflow: hidden;
    position: relative;
}

/* Chat Messages Section */
.chat-messages-container {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
    box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* Memory Panel */
.memory-panel {
    width: 0;
    min-width: 0;
    overflow: hidden;
    transition: none; /* Remove transition for manual resize */
    display: flex;
    flex-direction: column;
}

.memory-panel.active {
    width: 400px;
    min-width: 250px;
    max-width: 60%;
}

/* Loaded memories indicator */
.memory-panel.has-loaded-memories {
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
}

.memory-panel.has-loaded-memories .memory-panel-content {
    border-color: var(--synth-cyan);
    box-shadow: 0 2px 15px rgba(0, 255, 255, 0.2);
    background: linear-gradient(135deg,
        rgba(0, 255, 255, 0.03) 0%,
        var(--synth-card-bg) 100%);
}

/* Splitter for resizing */
.splitter {
    width: 8px;
    background: var(--synth-surface);
    border-left: 1px solid var(--synth-border);
    border-right: 1px solid var(--synth-border);
    cursor: col-resize;
    position: relative;
    flex-shrink: 0;
    display: none;
}

.splitter.active {
    display: block;
}

.splitter:hover,
.splitter.dragging {
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(0, 255, 255, 0.2) 50%, 
        transparent 100%);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

.splitter::after {
    content: 'â‹®';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--synth-text-muted);
    font-size: 1.2rem;
    opacity: 0.5;
}

.splitter:hover::after,
.splitter.dragging::after {
    color: var(--synth-cyan);
    opacity: 1;
}

.memory-panel-content {
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-border);
    border-radius: 8px;
    padding: 1rem;
    height: 100%;
    overflow-y: auto;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.memory-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--synth-border);
}

.memory-panel-title {
    color: var(--synth-cyan);
    font-size: 0.9rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.memory-count {
    background: linear-gradient(135deg, var(--synth-purple), var(--synth-pink));
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: bold;
}

.memory-item {
    background: var(--synth-surface);
    border-left: 3px solid var(--synth-purple);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
    border-radius: 4px;
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
}

.memory-item:hover {
    transform: translateX(5px);
    box-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);
    border-left-color: var(--synth-cyan);
}

.memory-score {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: linear-gradient(135deg, var(--synth-cyan), var(--synth-green));
    color: var(--synth-dark-bg);
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 255, 255, 0.3);
}

.memory-when {
    color: var(--synth-text-muted);
    font-size: 0.7rem;
    margin-bottom: 0.25rem;
}

.memory-what {
    color: var(--synth-text);
    font-size: 0.8rem;
    line-height: 1.4;
    margin-bottom: 0.5rem;
}

.memory-context {
    color: var(--synth-text-muted);
    font-size: 0.7rem;
    opacity: 0.8;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}


/* Token Budget Display */
.token-budget-display {
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    border-radius: 6px;
    padding: 0.5rem;
    margin-bottom: 0.75rem;
}

.token-budget-bar {
    height: 6px;
    background: var(--synth-dark-bg);
    border-radius: 3px;
    overflow: hidden;
    margin: 0.5rem 0;
}

.token-budget-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--synth-cyan), var(--synth-green));
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

.token-budget-text {
    display: flex;
    justify-content: space-between;
    font-size: 0.7rem;
    color: var(--synth-text-muted);
}

/* Memory Search Input */
.memory-search-box {
    margin-bottom: 1rem;
}

.memory-search-input {
    padding: 0.5rem;
    background: var(--synth-surface);
    border: 1px solid var(--synth-purple);
    color: var(--synth-text);
    border-radius: 4px;
    font-size: 0.8rem;
    font-family: inherit;
    transition: all 0.3s ease;
}

.memory-search-input:focus {
    outline: none;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

.memory-search-input::placeholder {
    color: var(--synth-text-muted);
    opacity: 0.6;
}

.memory-search-btn {
    padding: 0.5rem 1rem;
    background: linear-gradient(135deg, var(--synth-purple), var(--synth-cyan));
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 0.8rem;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}

.memory-search-btn:hover {
    background: linear-gradient(135deg, var(--synth-cyan), var(--synth-purple));
    box-shadow: 0 2px 10px rgba(0, 255, 255, 0.4);
}

/* Collapsible Controls Section */
.memory-controls-section {
    margin-top: 0.5rem;
    background: var(--synth-surface);
    border: 1px solid var(--synth-purple);
    border-radius: 6px;
    overflow: hidden;
}

.controls-toggle {
    width: 100%;
    padding: 0.75rem;
    background: linear-gradient(135deg,
        rgba(168, 85, 247, 0.1) 0%,
        rgba(0, 255, 255, 0.1) 100%);
    border: none;
    color: var(--synth-cyan);
    font-size: 0.85rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.3s ease;
}

.controls-toggle:hover {
    background: linear-gradient(135deg,
        rgba(168, 85, 247, 0.2) 0%,
        rgba(0, 255, 255, 0.2) 100%);
}

.toggle-icon {
    transition: transform 0.3s ease;
    font-size: 0.7rem;
}

.toggle-icon.expanded {
    transform: rotate(180deg);
}

.weight-status-mini {
    margin-left: auto;
    font-size: 0.7rem;
    padding: 0.2rem 0.4rem;
    background: var(--synth-green);
    color: var(--synth-dark-bg);
    border-radius: 12px;
}

.weight-status-mini.invalid {
    background: var(--synth-pink);
}

.memory-controls-content {
    padding: 1rem;
    border-top: 1px solid var(--synth-border);
    background: rgba(0, 0, 0, 0.3);
}

.control-group {
    margin-bottom: 1.5rem;
}

.control-group:last-child {
    margin-bottom: 0;
}

.control-group-title {
    color: var(--synth-cyan);
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.weight-sum-badge {
    background: linear-gradient(135deg, var(--synth-purple), var(--synth-cyan));
    color: white;
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: bold;
}

.weights-mini-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
}

.btn-mini {
    padding: 0.25rem 0.75rem;
    background: var(--synth-surface);
    border: 1px solid var(--synth-cyan);
    color: var(--synth-cyan);
    border-radius: 4px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-mini:hover {
    background: var(--synth-cyan);
    color: var(--synth-dark-bg);
    box-shadow: 0 2px 10px rgba(0, 255, 255, 0.3);
}

/* Mini Weight Sliders */
.weight-sliders-mini {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.weight-slider-mini {
    display: grid;
    grid-template-columns: 60px 1fr 40px;
    align-items: center;
    gap: 0.5rem;
}

.weight-slider-mini label {
    color: var(--synth-text-muted);
    font-size: 0.7rem;
}

.weight-slider-mini input[type="range"] {
    appearance: none;
    -webkit-appearance: none;
    height: 3px;
    background: var(--synth-border);
    outline: none;
    border-radius: 2px;
}

.weight-slider-mini input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: var(--synth-cyan);
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 6px var(--synth-cyan);
}

.weight-slider-mini span {
    color: var(--synth-cyan);
    font-family: monospace;
    font-size: 0.7rem;
    text-align: right;
}

/* Filter Controls within collapsible */
.filter-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.filter-row:last-child {
    margin-bottom: 0;
}

.filter-label {
    color: var(--synth-text-muted);
    font-size: 0.75rem;
    min-width: 70px;
}

.filter-input {
    flex: 1;
    padding: 0.25rem 0.5rem;
    background: var(--synth-dark-bg);
    border: 1px solid var(--synth-border);
    color: var(--synth-cyan);
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: inherit;
}

.filter-input:focus {
    outline: none;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
}

/* Hide number input spinners */
.filter-input[type="number"]::-webkit-inner-spin-button,
.filter-input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

.filter-input[type="number"] {
    appearance: textfield;
    -moz-appearance: textfield;
}

.filter-clear-btn {
    width: 100%;
    padding: 0.25rem 0.5rem;
    background: var(--synth-dark-bg);
    border: 1px solid var(--synth-border);
    color: var(--synth-text-muted);
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.filter-clear-btn:hover {
    border-color: var(--synth-pink);
    color: var(--synth-pink);
    box-shadow: 0 0 5px rgba(255, 16, 240, 0.3);
}

/* Memory Remove Button */
.memory-remove {
    display: inline-block;
    padding: 0.3rem 0.6rem;
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.2), rgba(255, 16, 240, 0.2));
    border: 1px solid var(--synth-pink);
    border-radius: 4px;
    color: var(--synth-pink);
    font-size: 0.7rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 0.5rem;
}

.memory-remove:hover {
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.4), rgba(255, 16, 240, 0.4));
    box-shadow: 0 2px 10px rgba(255, 16, 240, 0.4);
    transform: translateY(-1px);
}

/* Message Styles */
.message {
    margin-bottom: 1rem;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    animation: messageSlide 0.3s ease-out;
    position: relative;
}

.message.memory-enhanced {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.2);
}

.message.memory-enhanced::before {
    content: "ðŸ§ ";
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    font-size: 0.8rem;
    opacity: 0.6;
}

@keyframes messageSlide {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message.user {
    background: linear-gradient(135deg, 
        rgba(255, 16, 240, 0.15) 0%, 
        rgba(255, 16, 240, 0.05) 100%);
    border-left: 3px solid var(--synth-pink);
    margin-left: 2rem;
}

.message.assistant {
    background: linear-gradient(135deg,
        rgba(0, 255, 255, 0.15) 0%,
        rgba(0, 255, 255, 0.05) 100%);
    border-left: 3px solid var(--synth-cyan);
    margin-right: 2rem;
}

.message.system {
    background: linear-gradient(135deg,
        rgba(168, 85, 247, 0.15) 0%,
        rgba(168, 85, 247, 0.05) 100%);
    border-left: 3px solid var(--synth-purple);
    font-size: 0.8rem;
    color: var(--synth-text-muted);
}

/* Chat Input Area */
.chat-input-area {
    display: flex;
    gap: 1rem;
    padding: 1rem;
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-border);
    border-radius: 8px;
    box-shadow: 0 -2px 10px rgba(0, 255, 255, 0.1);
}

.chat-input {
    flex: 1;
    padding: 0.75rem;
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    color: var(--synth-text);
    border-radius: 4px;
    font-family: inherit;
    font-size: 0.875rem;
    resize: vertical;
    min-height: 60px;
    max-height: 200px;
    transition: all 0.3s ease;
}

.chat-input:focus {
    outline: none;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

.chat-input.with-loaded-memories {
    border-color: var(--synth-purple);
    box-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
    animation: pulse 3s infinite;
}

.chat-controls {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.send-button {
    padding: 0.75rem 2rem;
    background: linear-gradient(135deg, var(--synth-cyan), var(--synth-pink));
    color: var(--synth-dark-bg);
    border: none;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}


.send-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(255, 16, 240, 0.4);
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.token-counter {
    font-size: 0.75rem;
    color: var(--synth-text-muted);
    padding: 0.25rem 0.5rem;
    background: var(--synth-surface);
    border-radius: 4px;
    align-self: flex-end;
}

/* Loading Animation for Memory Search */
.memory-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    color: var(--synth-cyan);
}

.memory-loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--synth-surface);
    border-top: 3px solid var(--synth-cyan);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
}

/* AI Generation Indicator */
.ai-typing-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: linear-gradient(135deg,
        rgba(0, 255, 255, 0.1) 0%,
        rgba(168, 85, 247, 0.1) 100%);
    border-left: 3px solid var(--synth-cyan);
    border-radius: 8px;
    margin-bottom: 1rem;
    animation: messageSlide 0.3s ease-out;
}

.typing-dots {
    display: flex;
    gap: 0.3rem;
}

.typing-dot {
    width: 8px;
    height: 8px;
    background: var(--synth-cyan);
    border-radius: 50%;
    animation: typingDot 1.4s infinite;
    box-shadow: 0 0 10px var(--synth-cyan);
}

.typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typingDot {
    0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
    }
    30% {
        transform: translateY(-10px);
        opacity: 1;
    }
}

.typing-text {
    color: var(--synth-cyan);
    font-size: 0.875rem;
    font-style: italic;
    animation: pulse 2s infinite;
}

.memory-loading-text {
    margin-left: 1rem;
    font-size: 0.875rem;
    animation: pulse 1.5s infinite;
}

/* Settings Panel Updates */
.settings-panel {
    position: fixed;
    right: -500px;
    top: 80px;
    width: 500px;
    height: calc(100vh - 100px);
    background: var(--synth-card-bg);
    border: 1px solid var(--synth-cyan);
    border-radius: 8px 0 0 8px;
    padding: 1.5rem;
    transition: right 0.3s ease;
    z-index: 1000;
    overflow-y: auto;
    box-shadow: -4px 0 20px rgba(0, 255, 255, 0.2);
}

.settings-panel.visible {
    right: 0;
}

.settings-group {
    margin-bottom: 1.5rem;
}

.settings-group h3 {
    color: var(--synth-cyan);
    margin-bottom: 0.75rem;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.setting-label {
    font-size: 0.8rem;
    color: var(--synth-text-muted);
}

.setting-input {
    width: 150px;
    padding: 0.25rem 0.5rem;
    background: var(--synth-surface);
    border: 1px solid var(--synth-border);
    color: var(--synth-text);
    border-radius: 4px;
    font-size: 0.8rem;
    font-family: inherit;
}


/* Session Selector */
.session-selector {
    flex: 1;
    max-width: 300px;
    padding: 0.5rem 1rem;
    background: linear-gradient(135deg,
        rgba(0, 0, 0, 0.8) 0%,
        var(--synth-surface) 100%);
    border: 1px solid var(--synth-purple);
    color: var(--synth-cyan);
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
}

.session-selector:hover {
    border-color: var(--synth-pink);
    box-shadow: 0 0 15px rgba(255, 16, 240, 0.4),
                inset 0 1px 3px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg,
        rgba(255, 16, 240, 0.1) 0%,
        var(--synth-surface) 100%);
}

.session-selector:focus {
    outline: none;
    border-color: var(--synth-cyan);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5),
                inset 0 1px 3px rgba(0, 0, 0, 0.3);
}

.session-selector option {
    background: var(--synth-dark-bg);
    color: var(--synth-text);
    padding: 0.5rem;
}

.session-selector option:hover {
    background: var(--synth-surface);
    color: var(--synth-cyan);
}
</style>
{% endblock %}

{% block content %}
<div class="chat-container">
    <div class="chat-header">
        <select id="session-selector" class="session-selector">
            <option value="new">New Conversation</option>
        </select>
        <button class="synthwave-btn" onclick="toggleSettings()">
            <span class="btn-text">Settings</span>
        </button>
        <button class="synthwave-btn" onclick="exportChat()">
            <span class="btn-text">Export</span>
        </button>
        
        <!-- Memory Search Toggle -->
        <div class="memory-toggle-section">
            <span class="memory-toggle-label">Memory Search</span>
            <label class="toggle-switch">
                <input type="checkbox" id="memory-toggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span class="memory-status" id="memory-status">Active</span>
            <span id="loaded-memory-badge" style="display: none; background: linear-gradient(135deg, var(--synth-purple), var(--synth-pink)); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; font-weight: bold; margin-left: 0.5rem; box-shadow: 0 0 10px rgba(168, 85, 247, 0.4);">
                0 loaded
            </span>
        </div>
    </div>
    
    <div class="chat-main">
        <div class="chat-messages-container">
            <div id="chat-messages" class="chat-messages">
                <div class="message system">
                    <div class="message-content">
                        Welcome to JAM Chat with Memory Search. Your conversation will be enhanced with relevant memories from your knowledge base.
                    </div>
                </div>
            </div>
            
            <div class="chat-input-area">
                <textarea 
                    id="chat-input" 
                    class="chat-input" 
                    placeholder="Type your message... (Memory search is enabled - relevant memories will augment the response)"
                    rows="2"
                ></textarea>
                <div class="chat-controls">
                    <button id="send-button" class="send-button" onclick="sendMessage()">
                        Send
                    </button>
                    <span class="token-counter" id="token-counter">0 tokens</span>
                </div>
            </div>
        </div>
        
        <!-- Splitter for resizing -->
        <div id="splitter" class="splitter"></div>
        
        <!-- Memory Panel -->
        <div id="memory-panel" class="memory-panel">
            <div class="memory-panel-content">
                <div class="memory-panel-header">
                    <span class="memory-panel-title">Relevant Memories</span>
                    <span class="memory-count" id="memory-count">0</span>
                </div>
                
                <!-- Memory Search Box -->
                <div class="memory-search-box">
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <input 
                            type="text" 
                            id="memory-search-input" 
                            class="memory-search-input" 
                            placeholder="Enter search query..."
                            style="flex: 1;"
                        >
                        <button id="memory-search-btn" class="memory-search-btn" onclick="performManualSearch()">
                            Search
                        </button>
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <button id="load-memories-btn" class="memory-search-btn" onclick="loadMemoriesToContext()"
                                style="background: linear-gradient(135deg, var(--synth-purple), var(--synth-cyan));"
                                disabled>
                            Load into Context
                        </button>
                        <button id="clear-context-btn" class="memory-search-btn" onclick="clearMemoryContext()"
                                style="background: linear-gradient(135deg, var(--synth-pink), var(--synth-purple));"
                                disabled>
                            Clear Context
                        </button>
                    </div>
                    
                    <!-- Collapsible Filter & Weights Section -->
                    <div class="memory-controls-section">
                        <button class="controls-toggle" onclick="toggleMemoryControls()">
                            <span class="toggle-icon" id="controls-toggle-icon">â–¼</span>
                            <span>Filters & Scoring Weights</span>
                            <span id="weight-status-indicator" class="weight-status-mini">âœ“</span>
                        </button>

                        <div class="memory-controls-content" id="memory-controls-content" style="display: none;">
                            <!-- Filter Controls -->
                            <div class="control-group">
                                <h4 class="control-group-title">Display Filters</h4>
                                <div class="filter-row">
                                    <label class="filter-label">Min Score:</label>
                                    <input
                                        type="number"
                                        id="score-threshold"
                                        class="filter-input"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value="0.0"
                                        title="Only show memories with score above this threshold"
                                        style="appearance: textfield; -moz-appearance: textfield;"
                                    >
                                </div>
                                <div class="filter-row">
                                    <label class="filter-label">Top K:</label>
                                    <input
                                        type="number"
                                        id="top-k-limit"
                                        class="filter-input"
                                        min="1"
                                        max="100"
                                        value="10"
                                        title="Maximum number of memories to return"
                                        style="appearance: textfield; -moz-appearance: textfield;"
                                    >
                                </div>
                                <div class="filter-row">
                                    <button class="filter-clear-btn" onclick="clearFilters()">
                                        Clear Filters
                                    </button>
                                </div>
                            </div>

                            <!-- Scoring Weights -->
                            <div class="control-group">
                                <h4 class="control-group-title">Scoring Weights
                                    <span id="chat-weight-sum" class="weight-sum-badge">1.00</span>
                                </h4>
                                <div class="weights-mini-controls">
                                    <button onclick="normalizeWeights()" class="btn-mini">Normalize</button>
                                    <button onclick="resetWeights()" class="btn-mini">Reset</button>
                                </div>
                                <div class="weight-sliders-mini">
                                    <div class="weight-slider-mini">
                                        <label>Semantic</label>
                                        <input type="range" id="chat-weight-semantic" min="0" max="100" value="68" onchange="updateWeight('semantic', this.value)">
                                        <span id="chat-weight-semantic-val">0.68</span>
                                    </div>
                                    <div class="weight-slider-mini">
                                        <label>Recency</label>
                                        <input type="range" id="chat-weight-recency" min="0" max="100" value="2" onchange="updateWeight('recency', this.value)">
                                        <span id="chat-weight-recency-val">0.02</span>
                                    </div>
                                    <div class="weight-slider-mini">
                                        <label>Actor</label>
                                        <input type="range" id="chat-weight-actor" min="0" max="100" value="10" onchange="updateWeight('actor', this.value)">
                                        <span id="chat-weight-actor-val">0.10</span>
                                    </div>
                                    <div class="weight-slider-mini">
                                        <label>Temporal</label>
                                        <input type="range" id="chat-weight-temporal" min="0" max="100" value="10" onchange="updateWeight('temporal', this.value)">
                                        <span id="chat-weight-temporal-val">0.10</span>
                                    </div>
                                    <div class="weight-slider-mini">
                                        <label>Spatial</label>
                                        <input type="range" id="chat-weight-spatial" min="0" max="100" value="5" onchange="updateWeight('spatial', this.value)">
                                        <span id="chat-weight-spatial-val">0.05</span>
                                    </div>
                                    <div class="weight-slider-mini">
                                        <label>Usage</label>
                                        <input type="range" id="chat-weight-usage" min="0" max="100" value="5" onchange="updateWeight('usage', this.value)">
                                        <span id="chat-weight-usage-val">0.05</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Token Budget Display -->
                <div class="token-budget-display">
                    <div class="token-budget-text">
                        <span>Memory Tokens</span>
                        <span id="token-budget-info">0 / 2000</span>
                    </div>
                    <div class="token-budget-bar">
                        <div class="token-budget-fill" id="token-budget-fill" style="width: 0%"></div>
                    </div>
                </div>
                
                <!-- Memory Items Container -->
                <div id="memory-items">
                    <div class="memory-loading" style="display: none;">
                        <div class="memory-loading-spinner"></div>
                        <span class="memory-loading-text">Searching memories...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Memory Details Modal -->
<div id="memory-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Memory Details</h3>
            <span class="close" onclick="closeMemoryModal()">&times;</span>
        </div>
        <div class="modal-body" id="memory-modal-content">
            <!-- Content will be populated dynamically -->
        </div>
    </div>
</div>

<div id="settings-panel" class="settings-panel">
    <h2 style="color: var(--synth-cyan); margin-bottom: 1.5rem;">Chat Settings</h2>
    
    <div class="settings-group">
        <h3>Memory Search Settings</h3>
        <div class="setting-row">
            <span class="setting-label">Memory Token Budget</span>
            <input type="number" id="memory-token-budget" class="setting-input" value="2000" min="500" max="8000">
        </div>
        <div class="setting-row">
            <span class="setting-label">Initial Candidates</span>
            <input type="number" id="memory-candidates" class="setting-input" value="10000" min="100" max="50000">
        </div>
        <div class="setting-row">
            <span class="setting-label">Auto-Search</span>
            <input type="checkbox" id="auto-search" checked>
        </div>
    </div>
    
    <div class="settings-group">
        <h3>Model Parameters</h3>
        <div class="setting-row">
            <span class="setting-label">Temperature</span>
            <input type="number" id="temperature" class="setting-input" value="0.7" min="0" max="2" step="0.1">
        </div>
        <div class="setting-row">
            <span class="setting-label">Max Tokens</span>
            <input type="number" id="max-tokens" class="setting-input" value="2048" min="1" max="4096">
        </div>
    </div>
    
    <button class="synthwave-btn" onclick="saveSettings()" style="width: 100%;">
        <span class="btn-text">Save Settings</span>
    </button>
</div>

<script>
let currentSessionId = null;
let messageHistory = [];
let isStreaming = false;
let currentMemories = [];  // Current search results
let loadedMemories = [];   // Memories loaded into chat context
let memorySearchEnabled = true;
let removedMemoryIds = new Set(); // Track removed memories
let currentWeights = null; // Store current search weights

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    generateNewSession();
    setupEventListeners();
    loadSettings();
    fetchModelConfig();
    fetchWeights();
    updateLoadedMemoriesIndicator();  // Set initial visual state
    loadChatSessions();  // Load existing sessions
});

function generateNewSession() {
    const now = new Date();
    currentSessionId = `chat_${now.toISOString().replace(/[:.]/g, '-')}`;
    messageHistory = [];
    currentMemories = [];
    loadedMemories = [];  // Clear loaded memories on new session
    document.getElementById('chat-messages').innerHTML = `
        <div class="message system">
            <div class="message-content">
                New conversation started. Session ID: ${currentSessionId}
                Memory search is ${memorySearchEnabled ? 'enabled' : 'disabled'}.
            </div>
        </div>
    `;
    clearMemoryPanel();
}

function setupEventListeners() {
    const input = document.getElementById('chat-input');
    const memoryToggle = document.getElementById('memory-toggle');
    const memorySearchInput = document.getElementById('memory-search-input');
    const sessionSelector = document.getElementById('session-selector');

    // Handle session selection
    sessionSelector.addEventListener('change', (e) => {
        if (e.target.value === 'new') {
            generateNewSession();
        } else {
            loadSession(e.target.value);
        }
    });
    
    // Handle Enter key
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Update token count
    input.addEventListener('input', updateTokenCount);
    
    // Memory toggle
    memoryToggle.addEventListener('change', (e) => {
        memorySearchEnabled = e.target.checked;
        const status = document.getElementById('memory-status');
        const panel = document.getElementById('memory-panel');
        const splitter = document.getElementById('splitter');
        const inputEl = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-button');
        
        if (memorySearchEnabled) {
            status.textContent = 'Active';
            status.classList.add('active');
            panel.classList.add('active');
            splitter.classList.add('active');
            inputEl.placeholder = 'Type your message... (Memory search panel is active)';
        } else {
            status.textContent = 'Inactive';
            status.classList.remove('active');
            panel.classList.remove('active');
            splitter.classList.remove('active');
            inputEl.placeholder = 'Type your message... (Memory search panel is hidden)';
        }
    });
    
    // Memory search input - Enter key to search
    memorySearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            performManualSearch();
        }
    });
    
    // Initialize memory panel state
    if (memorySearchEnabled) {
        document.getElementById('memory-panel').classList.add('active');
        document.getElementById('splitter').classList.add('active');
        document.getElementById('memory-status').classList.add('active');
        document.getElementById('chat-input').classList.add('memory-active');
        document.getElementById('send-button').classList.add('memory-active');
    }
    
    // Setup splitter resize functionality
    setupSplitterResize();
}

function setupSplitterResize() {
    const splitter = document.getElementById('splitter');
    const memoryPanel = document.getElementById('memory-panel');
    const chatContainer = document.querySelector('.chat-messages-container');
    const mainContainer = document.querySelector('.chat-main');
    
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    splitter.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = memoryPanel.offsetWidth;
        splitter.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const deltaX = startX - e.clientX;
        const newWidth = Math.min(
            Math.max(250, startWidth + deltaX), // Min 250px
            mainContainer.offsetWidth * 0.6 // Max 60% of container
        );
        
        memoryPanel.style.width = newWidth + 'px';
        e.preventDefault();
    });
    
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            splitter.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
    });
}

function updateTokenCount() {
    const text = document.getElementById('chat-input').value;
    const tokens = Math.ceil(text.length / 4);
    document.getElementById('token-counter').textContent = `${tokens} tokens`;
}

async function sendMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();

    if (!message || isStreaming) return;

    // Add user message to UI
    addMessage('user', message);

    // Clear input
    input.value = '';
    updateTokenCount();

    // Disable send button
    const sendBtn = document.getElementById('send-button');
    sendBtn.disabled = true;
    isStreaming = true;

    // Show typing indicator
    showTypingIndicator();

    // No automatic memory search - use loaded memories instead

    try {
        // Prepare messages for API
        const messages = [...messageHistory, { role: 'user', content: message }];
        
        // Get settings
        const settings = {
            temperature: parseFloat(document.getElementById('temperature').value),
            max_tokens: parseInt(document.getElementById('max-tokens').value),
            memory_search: false,  // Disable server-side memory search
            memory_context: loadedMemories.length > 0 ? loadedMemories : null  // Send loaded memories
        };
        
        // Send to API
        const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                messages: messages,
                session_id: currentSessionId,
                ...settings
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Hide typing indicator
        hideTypingIndicator();

        // Add assistant message
        if (data.choices && data.choices[0]) {
            const assistantMessage = data.choices[0].message.content;
            const isMemoryEnhanced = loadedMemories.length > 0;  // Check loaded memories instead
            addMessage('assistant', assistantMessage, data.memory_ids, false, isMemoryEnhanced);
        }

        // Refresh session list to include this conversation
        await loadChatSessions();
        // Keep current session selected
        document.getElementById('session-selector').value = currentSessionId;

    } catch (error) {
        console.error('Error:', error);
        hideTypingIndicator();
        addMessage('system', `Error: ${error.message}`, null, true);
    } finally {
        sendBtn.disabled = false;
        isStreaming = false;
    }
}

async function performMemorySearch(query, applyFilters = true) {
    const memoryItems = document.getElementById('memory-items');

    // Show loading
    memoryItems.innerHTML = `
        <div class="memory-loading">
            <div class="memory-loading-spinner"></div>
            <span class="memory-loading-text">Searching memories...</span>
        </div>
    `;

    try {
        const tokenBudget = parseInt(document.getElementById('memory-token-budget').value) || window.memoryTokenBudget || 2000;

        // Match analyzer tab behavior - don't send filters to server
        const response = await fetch('/api/memory/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                query: query,
                weights: currentWeights,
                token_budget: tokenBudget,
                initial_candidates: parseInt(document.getElementById('memory-candidates').value) || 10000,
                // Don't send score_threshold and top_k - let knapsack do its work
                removed_ids: Array.from(removedMemoryIds)
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        // Store all memories returned by knapsack
        let memories = data.memories || [];

        // Apply client-side filtering if requested (for manual filter controls)
        if (applyFilters) {
            const scoreThreshold = parseFloat(document.getElementById('score-threshold').value) || 0.0;
            const topK = parseInt(document.getElementById('top-k-limit').value) || 0;

            // Filter by score threshold
            if (scoreThreshold > 0) {
                memories = memories.filter(m => m.total_score >= scoreThreshold);
            }

            // Limit to top K
            if (topK > 0) {
                memories = memories.slice(0, topK);
            }
        }

        currentMemories = memories;

        // Update UI with client-filtered data
        data.memories = memories;
        updateMemoryPanel(data);

    } catch (error) {
        console.error('Memory search error:', error);
        memoryItems.innerHTML = `
            <div class="message system">
                <div class="message-content">Error searching memories: ${error.message}</div>
            </div>
        `;
    }
}

async function performManualSearch() {
    const searchQuery = document.getElementById('memory-search-input').value.trim();
    if (searchQuery) {
        await performMemorySearch(searchQuery, true);
        // Enable load button after successful search
        document.getElementById('load-memories-btn').disabled = currentMemories.length === 0;
    } else {
        // Clear results if search is empty
        clearMemoryPanel();
        document.getElementById('load-memories-btn').disabled = true;
    }
}

function loadMemoriesToContext() {
    if (currentMemories.length === 0) {
        addMessage('system', 'No memories to load. Please search for memories first.');
        return;
    }

    // Load current search results into context
    loadedMemories = [...currentMemories];

    // Update UI to show loaded state
    updateLoadedMemoriesIndicator();

    // Enable clear button
    document.getElementById('clear-context-btn').disabled = false;

    // Add system message
    addMessage('system', `Loaded ${loadedMemories.length} memories into chat context. These memories will be available to the AI for all subsequent messages.`);
}

function clearMemoryContext() {
    loadedMemories = [];

    // Update UI
    updateLoadedMemoriesIndicator();

    // Disable clear button
    document.getElementById('clear-context-btn').disabled = true;

    // Add system message
    addMessage('system', 'Memory context cleared. The AI will respond without any pre-loaded memories.');
}

function updateLoadedMemoriesIndicator() {
    // Update the memory panel header to show loaded state
    const memoryPanelTitle = document.querySelector('.memory-panel-title');
    const memoryPanel = document.getElementById('memory-panel');
    const memoryCount = document.getElementById('memory-count');
    const loadedBadge = document.getElementById('loaded-memory-badge');

    if (loadedMemories.length > 0) {
        // Update title with loaded count
        memoryPanelTitle.innerHTML = `Relevant Memories <span style="color: var(--synth-purple);">(${loadedMemories.length} loaded)</span>`;
        memoryPanelTitle.style.animation = 'pulse 2s infinite';

        // Add visual indicator to panel
        memoryPanel.classList.add('has-loaded-memories');

        // Show and update loaded badge in header
        loadedBadge.style.display = 'inline-block';
        loadedBadge.textContent = `${loadedMemories.length} loaded`;
        loadedBadge.style.animation = 'pulse 2s infinite';

        // Update input placeholder and style
        const chatInput = document.getElementById('chat-input');
        chatInput.placeholder = `Type your message... (${loadedMemories.length} memories loaded in context)`;
        chatInput.classList.add('with-loaded-memories');

        // Update send button to show loaded state
        const sendBtn = document.getElementById('send-button');
        sendBtn.style.background = 'linear-gradient(135deg, var(--synth-purple), var(--synth-pink))';
    } else {
        // Reset title
        memoryPanelTitle.innerHTML = 'Relevant Memories';
        memoryPanelTitle.style.animation = 'none';

        // Remove visual indicator from panel
        memoryPanel.classList.remove('has-loaded-memories');

        // Hide loaded badge
        loadedBadge.style.display = 'none';
        loadedBadge.style.animation = 'none';

        // Reset input placeholder and style
        const chatInput = document.getElementById('chat-input');
        chatInput.placeholder = 'Type your message... (No memories loaded - use search to find and load memories)';
        chatInput.classList.remove('with-loaded-memories');

        // Reset send button
        const sendBtn = document.getElementById('send-button');
        sendBtn.style.background = '';
    }
}

function removeMemory(memoryId) {
    removedMemoryIds.add(memoryId);
    
    // Remove from current memories
    currentMemories = currentMemories.filter(m => m.memory_id !== memoryId);
    
    // Update UI
    const memoryItem = document.querySelector(`[data-memory-id="${memoryId}"]`);
    if (memoryItem) {
        memoryItem.style.transition = 'all 0.3s ease';
        memoryItem.style.opacity = '0';
        memoryItem.style.transform = 'translateX(-20px)';
        setTimeout(() => memoryItem.remove(), 300);
        
        // Update count
        const memoryCount = document.getElementById('memory-count');
        memoryCount.textContent = currentMemories.length;
    }
}

function clearFilters() {
    document.getElementById('score-threshold').value = '0.0';
    document.getElementById('top-k-limit').value = '10';

    // Re-run search if there's a query
    const searchQuery = document.getElementById('memory-search-input').value.trim();
    if (searchQuery) {
        performManualSearch();
    }
}

function formatDateTime(dateStr) {
    if (!dateStr) return 'Unknown time';
    try {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) return dateStr;
        
        const options = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        };
        return date.toLocaleString('en-US', options);
    } catch (e) {
        return dateStr;
    }
}

function updateMemoryPanel(searchResult) {
    const memoryItems = document.getElementById('memory-items');
    const memoryCount = document.getElementById('memory-count');
    const tokenBudgetInfo = document.getElementById('token-budget-info');
    const tokenBudgetFill = document.getElementById('token-budget-fill');
    
    // Update counts
    memoryCount.textContent = searchResult.selected_count || 0;
    
    // Update token budget
    const tokensUsed = searchResult.tokens_used || 0;
    const tokenBudget = searchResult.token_budget || 2000;
    const percentage = (tokensUsed / tokenBudget) * 100;
    
    tokenBudgetInfo.textContent = `${tokensUsed} / ${tokenBudget}`;
    tokenBudgetFill.style.width = `${percentage}%`;
    
    // Clear and populate memories
    memoryItems.innerHTML = '';
    
    if (searchResult.memories && searchResult.memories.length > 0) {
        searchResult.memories.forEach((memory, index) => {
            const memoryDiv = document.createElement('div');
            memoryDiv.className = 'memory-item';
            memoryDiv.style.position = 'relative';
            memoryDiv.setAttribute('data-memory-id', memory.memory_id);
            memoryDiv.innerHTML = `
                <div class="memory-score">${memory.total_score.toFixed(2)}</div>
                <div class="memory-when">${formatDateTime(memory.when)}</div>
                <div class="memory-what">${escapeHtml(memory.what || 'No description')}</div>
                <div class="memory-context">${escapeHtml((memory.raw_text || '').substring(0, 150))}...</div>
                <button class="memory-remove" onclick="event.stopPropagation(); removeMemory('${memory.memory_id}')" title="Remove">Remove</button>
            `;
            memoryDiv.onclick = () => showMemoryDetails(memory);
            memoryItems.appendChild(memoryDiv);
        });
    } else {
        memoryItems.innerHTML = `
            <div class="message system">
                <div class="message-content">No relevant memories found.</div>
            </div>
        `;
    }
}

function clearMemoryPanel() {
    document.getElementById('memory-items').innerHTML = `
        <div class="message system">
            <div class="message-content">Memory search will activate when you send a message.</div>
        </div>
    `;
    document.getElementById('memory-count').textContent = '0';
    document.getElementById('token-budget-info').textContent = '0 / 2000';
    document.getElementById('token-budget-fill').style.width = '0%';
}

function addMessage(role, content, memoryIds = null, isError = false, isMemoryEnhanced = false) {
    const messagesDiv = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}${isError ? ' error-message' : ''}${isMemoryEnhanced ? ' memory-enhanced' : ''}`;
    
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    
    let memoryIndicator = '';
    if (memoryIds && memoryIds.length > 0) {
        memoryIndicator = `<span class="memory-indicator">âœ“ Saved to memory (${memoryIds.length} parts)</span>`;
    }
    
    messageDiv.innerHTML = `
        <div class="message-header">
            <span class="message-role">${role}</span>
            <span class="message-time">${timeStr}</span>
            ${memoryIndicator}
        </div>
        <div class="message-content">${escapeHtml(content)}</div>
    `;
    
    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    // Add to history if not system/error
    if (!isError && role !== 'system') {
        messageHistory.push({ role, content });
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showTypingIndicator() {
    const messagesDiv = document.getElementById('chat-messages');

    // Remove any existing typing indicator
    hideTypingIndicator();

    // Create typing indicator element
    const typingDiv = document.createElement('div');
    typingDiv.id = 'ai-typing-indicator';
    typingDiv.className = 'ai-typing-indicator';
    typingDiv.innerHTML = `
        <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        </div>
        <span class="typing-text">Generating..</span>
    `;

    messagesDiv.appendChild(typingDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function hideTypingIndicator() {
    const indicator = document.getElementById('ai-typing-indicator');
    if (indicator) {
        indicator.remove();
    }
}

function showMemoryDetails(memory) {
    const modalContent = document.getElementById('memory-modal-content');
    
    // Format scores if available
    let scoresHtml = '';
    if (memory.scores && Object.keys(memory.scores).length > 0) {
        const scoreItems = Object.entries(memory.scores).map(([key, value]) => `
            <div class="score-item">
                <span class="score-label">${key}</span>
                <span class="score-value">${(value * 100).toFixed(1)}%</span>
            </div>
        `).join('');
        scoresHtml = `
            <div class="detail-section">
                <h5>Relevance Scores</h5>
                <div class="score-breakdown">
                    ${scoreItems}
                </div>
            </div>
        `;
    }
    
    modalContent.innerHTML = `
        <div class="memory-detail">
            <div class="detail-section">
                <h5>Metadata</h5>
                <div class="detail-grid">
                    <div><strong>Memory ID:</strong> ${memory.memory_id}</div>
                    <div><strong>Total Score:</strong> ${memory.total_score.toFixed(3)}</div>
                    <div><strong>Token Count:</strong> ${memory.token_count || 'N/A'}</div>
                    <div><strong>Created:</strong> ${formatDateTime(memory.when)}</div>
                </div>
            </div>
            
            ${scoresHtml}
            
            <div class="detail-section">
                <h5>5W1H Information</h5>
                <div class="detail-grid">
                    <div><strong>WHO:</strong> ${escapeHtml(memory.who || 'Unknown')}</div>
                    <div><strong>WHAT:</strong> ${escapeHtml(memory.what || 'No description')}</div>
                    <div><strong>WHEN:</strong> ${formatDateTime(memory.when)}</div>
                    <div><strong>WHERE:</strong> ${escapeHtml(memory.where || 'No location')}</div>
                    <div><strong>WHY:</strong> ${escapeHtml(memory.why || 'No reason provided')}</div>
                    <div><strong>HOW:</strong> ${escapeHtml(memory.how || 'No method described')}</div>
                </div>
            </div>
            
            <div class="detail-section">
                <h5>Raw Context</h5>
                <div class="raw-text-display">${escapeHtml(memory.raw_text || 'No context available')}</div>
            </div>
        </div>
    `;
    
    // Show modal
    document.getElementById('memory-modal').style.display = 'block';
    
    // Store current memory for potential further actions
    window.currentDetailMemory = memory;
}

function closeMemoryModal() {
    document.getElementById('memory-modal').style.display = 'none';
    window.currentDetailMemory = null;
}

// Close modal on escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeMemoryModal();
    }
});

// Close modal on overlay click
window.onclick = function(event) {
    const modal = document.getElementById('memory-modal');
    if (event.target === modal) {
        modal.style.display = 'none';
        window.currentDetailMemory = null;
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function toggleSettings() {
    const panel = document.getElementById('settings-panel');
    panel.classList.toggle('visible');
}

function saveSettings() {
    // Settings are applied in real-time
    toggleSettings();
}

function loadSettings() {
    // Load from localStorage or use defaults
    const settings = JSON.parse(localStorage.getItem('chatSettings') || '{}');
    
    if (settings.memoryTokenBudget !== undefined) {
        document.getElementById('memory-token-budget').value = settings.memoryTokenBudget;
    }
    if (settings.memoryCandidates !== undefined) {
        document.getElementById('memory-candidates').value = settings.memoryCandidates;
    }
}

async function fetchModelConfig() {
    try {
        const response = await fetch('/api/model_config');
        if (response.ok) {
            const config = await response.json();
            
            // Update memory token budget with the analyzer's default
            const defaultBudget = config.default_budget || 2000;
            document.getElementById('memory-token-budget').value = defaultBudget;
            
            // Update the display
            document.getElementById('token-budget-info').textContent = `0 / ${defaultBudget}`;
            
            // Store for later use
            window.memoryTokenBudget = defaultBudget;
        }
    } catch (error) {
        console.error('Error fetching model config:', error);
    }
}

async function fetchWeights() {
    try {
        const response = await fetch('/api/weights');
        if (response.ok) {
            currentWeights = await response.json();
            console.log('Loaded weights:', currentWeights);
            updateChatWeightDisplay();
        }
    } catch (error) {
        console.error('Error fetching weights:', error);
        // Use default weights if fetch fails
        currentWeights = {
            semantic: 0.68,
            recency: 0.02,
            actor: 0.10,
            temporal: 0.10,
            spatial: 0.05,
            usage: 0.05
        };
        updateChatWeightDisplay();
    }
}

function toggleMemoryControls() {
    const content = document.getElementById('memory-controls-content');
    const icon = document.getElementById('controls-toggle-icon');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.classList.add('expanded');
    } else {
        content.style.display = 'none';
        icon.classList.remove('expanded');
    }
}

function updateChatWeightDisplay() {
    // Update all weight sliders and values in chat panel
    for (const [dimension, value] of Object.entries(currentWeights)) {
        const slider = document.getElementById(`chat-weight-${dimension}`);
        const valSpan = document.getElementById(`chat-weight-${dimension}-val`);

        if (slider) {
            slider.value = value * 100;
        }
        if (valSpan) {
            valSpan.textContent = value.toFixed(2);
        }
    }
    updateChatWeightSum();
}

function updateChatWeightSum() {
    const sum = Object.values(currentWeights).reduce((a, b) => a + b, 0);
    const sumSpan = document.getElementById('chat-weight-sum');
    const statusIndicator = document.getElementById('weight-status-indicator');

    if (sumSpan) {
        sumSpan.textContent = sum.toFixed(2);
        const isNormalized = Math.abs(sum - 1.0) < 0.001;

        if (statusIndicator) {
            if (isNormalized) {
                statusIndicator.textContent = 'âœ“';
                statusIndicator.classList.remove('invalid');
            } else {
                statusIndicator.textContent = '!';
                statusIndicator.classList.add('invalid');
            }
        }
    }
}

// Update weight value - shared with analyzer
async function updateWeight(dimension, value) {
    const floatValue = value / 100;
    currentWeights[dimension] = floatValue;

    // Update both analyzer and chat displays
    const analyzerValSpan = document.getElementById(`weight-${dimension}-val`);
    const analyzerSlider = document.getElementById(`weight-${dimension}`);
    const chatValSpan = document.getElementById(`chat-weight-${dimension}-val`);
    const chatSlider = document.getElementById(`chat-weight-${dimension}`);

    if (analyzerValSpan) analyzerValSpan.textContent = floatValue.toFixed(2);
    if (analyzerSlider) analyzerSlider.value = value;
    if (chatValSpan) chatValSpan.textContent = floatValue.toFixed(2);
    if (chatSlider) chatSlider.value = value;

    // Update sums for both panels
    if (typeof updateWeightSum === 'function') updateWeightSum();
    updateChatWeightSum();

    // Save weights to server
    try {
        await fetch('/api/weights', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(currentWeights)
        });
    } catch (error) {
        console.error('Failed to save weights:', error);
    }
}

// Normalize weights to sum to 1.0 - shared with analyzer
async function normalizeWeights() {
    try {
        const response = await fetch('/api/weights', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(currentWeights)
        });

        if (response.ok) {
            const data = await response.json();
            currentWeights = data.weights;

            // Update both panels
            if (typeof updateWeightDisplay === 'function') updateWeightDisplay();
            updateChatWeightDisplay();

            // Re-search if there's a query in memory search
            const searchQuery = document.getElementById('memory-search-input').value.trim();
            if (searchQuery) {
                performManualSearch();
            }
        }
    } catch (error) {
        console.error('Failed to normalize weights:', error);
    }
}

// Reset weights to defaults - shared with analyzer
async function resetWeights() {
    try {
        const response = await fetch('/api/weights/reset', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        });

        if (response.ok) {
            const data = await response.json();
            currentWeights = data.weights;

            // Update both panels
            if (typeof updateWeightDisplay === 'function') updateWeightDisplay();
            updateChatWeightDisplay();

            // Re-search if there's a query
            const searchQuery = document.getElementById('memory-search-input').value.trim();
            if (searchQuery) {
                performManualSearch();
            }
        }
    } catch (error) {
        console.error('Failed to reset weights:', error);
        // Fallback to local defaults
        currentWeights = {
            semantic: 0.68,
            recency: 0.02,
            actor: 0.10,
            temporal: 0.10,
            spatial: 0.05,
            usage: 0.05
        };
        updateChatWeightDisplay();
    }
}

async function loadChatSessions() {
    try {
        const response = await fetch('/api/chat/sessions');
        if (!response.ok) return;

        const sessions = await response.json();
        const selector = document.getElementById('session-selector');

        // Clear existing options except "New Conversation"
        selector.innerHTML = '<option value="new">New Conversation</option>';

        // Add existing sessions
        sessions.forEach(session => {
            const option = document.createElement('option');
            option.value = session.session_id;

            // Format the session display name
            const date = new Date(session.start_time);
            const dateStr = date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            option.textContent = `${dateStr} (${session.message_count} messages)`;
            selector.appendChild(option);
        });
    } catch (error) {
        console.error('Error loading sessions:', error);
    }
}

async function loadSession(sessionId) {
    try {
        const response = await fetch(`/api/chat/session/${sessionId}`);
        if (!response.ok) {
            throw new Error('Failed to load session');
        }

        const data = await response.json();

        // Clear current chat
        currentSessionId = sessionId;
        messageHistory = [];
        currentMemories = [];
        loadedMemories = [];
        removedMemoryIds.clear();

        // Clear chat display
        const messagesDiv = document.getElementById('chat-messages');
        messagesDiv.innerHTML = '';

        // Load messages from history
        data.messages.forEach(msg => {
            addMessage(msg.role, msg.content);
        });

        // Add system message about loaded session
        const firstMessageTime = data.messages.length > 0 ? data.messages[0].timestamp : null;
        if (firstMessageTime) {
            addMessage('system', `Loaded conversation from ${new Date(firstMessageTime).toLocaleString()}`);
        } else {
            addMessage('system', 'Loaded conversation');
        }

        // Update UI
        updateLoadedMemoriesIndicator();
        clearMemoryPanel();
    } catch (error) {
        console.error('Error loading session:', error);
        addMessage('system', `Error loading session: ${error.message}`);
    }
}

async function exportChat() {
    const data = {
        session_id: currentSessionId,
        messages: messageHistory,
        memories_used: currentMemories.map(m => ({
            memory_id: m.memory_id,
            score: m.total_score,
            what: m.what
        })),
        timestamp: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `chat_${currentSessionId}.json`;
    a.click();
    URL.revokeObjectURL(url);
}
</script>
{% endblock %}
